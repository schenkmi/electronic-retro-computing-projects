// ***************************************************************************
// *****                                                                 *****
// ***** AtMega328P UART ANSI Terminal with 60x25 Character VGA and PS/2 *****
// *****                                                                 *****
// *****        written by Carsten Herting 02.06.2021 Version 2.2        *****
// *****                                                                 *****
// ***************************************************************************
// Pin C0-5: terminal input bits 0-5
// Pin D0-7: parallel pixel output to 74166, in between: D6-7 terminal input bits 6-7
// Pin B0:   CLKO ATmega328 system clock output
// Pin B1:   DATA_NEW input handshake
// Pin B2:   /VSYNC VGA (timer1, every 1/60s, could also be done)
// Pin B3:   /PE low pulse (by hand inside ISR for 74166 /PE pixel shift register sync parallel load)
// Pin B4:   /HSYNC VGA (by hand inside ISR, every 32Âµs)
// Pin B5:   DATA_ACK output handshake
// See license at the end of this file.

#define WIDTH     60
#define HEIGHT    25

char row = 0, col = 0;            // current cursor position in terminal window
volatile int vline = 0;           // current vertical position of pixel video output
volatile byte vram[HEIGHT][WIDTH];// array of VideoRAM
volatile char start = 0;          // start line of the VideoRAM (thus avoiding moving data while scrolling)
volatile int frames = 0;          // 1/60s frame counter for cursor blinking
volatile byte regout = 0;         // index of current output position in queue
volatile byte regin = 0;          // index of current input position in queue
volatile byte __attribute__ ((aligned (256))) reg[256];   // ring buffer data of keyboard input register

const volatile byte __attribute__ ((aligned (256))) charset[8][256] PROGMEM =
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x00,0x18,0x66,0x66,0x18,0x62,0x3C,0x06,0x0C,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x18,0x3C,0x3C,0x06,0x7E,0x3C,0x7E,0x3C,0x3C,0x00,0x00,0x0E,0x00,0x70,0x3C,0x3C,0x18,0x7C,0x3C,0x78,0x7E,0x7E,0x3C,0x66,0x3C,0x1E,0x66,0x60,0x63,0x66,0x3C,0x7C,0x3C,0x7C,0x3C,0x7E,0x66,0x66,0x63,0x66,0x66,0x7E,0x3C,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x18,0x70,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0xFF,0xFF,0x01,0x80,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0xE7,0x99,0x99,0xE7,0x9D,0xC3,0xF9,0xF3,0xCF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC3,0xE7,0xC3,0xC3,0xF9,0x81,0xC3,0x81,0xC3,0xC3,0xFF,0xFF,0xF1,0xFF,0x8F,0xC3,0xC3,0xE7,0x83,0xC3,0x87,0x81,0x81,0xC3,0x99,0xC3,0xE1,0x99,0x9F,0x9C,0x99,0xC3,0x83,0xC3,0x83,0xC3,0x81,0x99,0x99,0x9C,0x99,0x99,0x81,0xC3,0xFF,0xC3,0xFF,0xFF,0xC3,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF1,0xE7,0x8F,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x00,0x18,0x66,0x66,0x3E,0x66,0x66,0x0C,0x18,0x18,0x66,0x18,0x00,0x00,0x00,0x03,0x66,0x18,0x66,0x66,0x0E,0x60,0x66,0x66,0x66,0x66,0x00,0x00,0x18,0x00,0x18,0x66,0x66,0x3C,0x66,0x66,0x6C,0x60,0x60,0x66,0x66,0x18,0x0C,0x6C,0x60,0x77,0x76,0x66,0x66,0x66,0x66,0x66,0x18,0x66,0x66,0x63,0x66,0x66,0x06,0x30,0x60,0x0C,0x18,0x00,0x66,0x00,0x60,0x00,0x06,0x00,0x0E,0x00,0x60,0x18,0x06,0x60,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x00,0x10,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x7F,0xFE,0x03,0xC0,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0xE7,0x99,0x99,0xC1,0x99,0x99,0xF3,0xE7,0xE7,0x99,0xE7,0xFF,0xFF,0xFF,0xFC,0x99,0xE7,0x99,0x99,0xF1,0x9F,0x99,0x99,0x99,0x99,0xFF,0xFF,0xE7,0xFF,0xE7,0x99,0x99,0xC3,0x99,0x99,0x93,0x9F,0x9F,0x99,0x99,0xE7,0xF3,0x93,0x9F,0x88,0x89,0x99,0x99,0x99,0x99,0x99,0xE7,0x99,0x99,0x9C,0x99,0x99,0xF9,0xCF,0x9F,0xF3,0xE7,0xFF,0x99,0xFF,0x9F,0xFF,0xF9,0xFF,0xF1,0xFF,0x9F,0xE7,0xF9,0x9F,0xC7,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE7,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE7,0xE7,0xE7,0xFF,0xEF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x70,0x00,0x18,0x66,0xFF,0x60,0x0C,0x3C,0x18,0x30,0x0C,0x3C,0x18,0x00,0x00,0x00,0x06,0x6E,0x38,0x06,0x06,0x1E,0x7C,0x60,0x0C,0x66,0x66,0x18,0x18,0x30,0x7E,0x0C,0x06,0x6E,0x66,0x66,0x60,0x66,0x60,0x60,0x60,0x66,0x18,0x0C,0x78,0x60,0x7F,0x7E,0x66,0x66,0x66,0x66,0x60,0x18,0x66,0x66,0x63,0x3C,0x66,0x0C,0x30,0x30,0x0C,0x3C,0x00,0x6E,0x3C,0x60,0x3C,0x06,0x3C,0x18,0x3E,0x60,0x00,0x00,0x60,0x18,0x66,0x7C,0x3C,0x7C,0x3E,0x7C,0x3E,0x7E,0x66,0x66,0x63,0x66,0x66,0x7E,0x18,0x18,0x18,0x00,0x30,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x1C,0x38,0x3F,0xFC,0x07,0xE0,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0xE7,0x99,0x00,0x9F,0xF3,0xC3,0xE7,0xCF,0xF3,0xC3,0xE7,0xFF,0xFF,0xFF,0xF9,0x91,0xC7,0xF9,0xF9,0xE1,0x83,0x9F,0xF3,0x99,0x99,0xE7,0xE7,0xCF,0x81,0xF3,0xF9,0x91,0x99,0x99,0x9F,0x99,0x9F,0x9F,0x9F,0x99,0xE7,0xF3,0x87,0x9F,0x80,0x81,0x99,0x99,0x99,0x99,0x9F,0xE7,0x99,0x99,0x9C,0xC3,0x99,0xF3,0xCF,0xCF,0xF3,0xC3,0xFF,0x91,0xC3,0x9F,0xC3,0xF9,0xC3,0xE7,0xC1,0x9F,0xFF,0xFF,0x9F,0xE7,0x99,0x83,0xC3,0x83,0xC1,0x83,0xC1,0x81,0x99,0x99,0x9C,0x99,0x99,0x81,0xE7,0xE7,0xE7,0xFF,0xCF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x38,0x00,0x18,0x00,0x66,0x3C,0x18,0x38,0x00,0x30,0x0C,0xFF,0x7E,0x00,0x7E,0x00,0x0C,0x76,0x18,0x0C,0x1C,0x66,0x06,0x7C,0x18,0x3C,0x3E,0x00,0x00,0x60,0x00,0x06,0x0C,0x6E,0x7E,0x7C,0x60,0x66,0x78,0x78,0x6E,0x7E,0x18,0x0C,0x70,0x60,0x6B,0x7E,0x66,0x7C,0x66,0x7C,0x3C,0x18,0x66,0x66,0x6B,0x18,0x3C,0x18,0x30,0x18,0x0C,0x7E,0x00,0x6E,0x06,0x7C,0x60,0x3E,0x66,0x3E,0x66,0x7C,0x38,0x06,0x6C,0x18,0x7F,0x66,0x66,0x66,0x66,0x66,0x60,0x18,0x66,0x66,0x6B,0x3C,0x66,0x0C,0x70,0x18,0x0E,0x3B,0x7F,0x1F,0xFF,0xF8,0x1F,0xFF,0xF8,0x1F,0xFF,0xF8,0xFF,0x07,0xE0,0x0F,0xF0,0x1F,0xF8,0x0F,0xF0,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0x00,0x0F,0xF0,0xFF,0xE7,0xFF,0x99,0xC3,0xE7,0xC7,0xFF,0xCF,0xF3,0x00,0x81,0xFF,0x81,0xFF,0xF3,0x89,0xE7,0xF3,0xE3,0x99,0xF9,0x83,0xE7,0xC3,0xC1,0xFF,0xFF,0x9F,0xFF,0xF9,0xF3,0x91,0x81,0x83,0x9F,0x99,0x87,0x87,0x91,0x81,0xE7,0xF3,0x8F,0x9F,0x94,0x81,0x99,0x83,0x99,0x83,0xC3,0xE7,0x99,0x99,0x94,0xE7,0xC3,0xE7,0xCF,0xE7,0xF3,0x81,0xFF,0x91,0xF9,0x83,0x9F,0xC1,0x99,0xC1,0x99,0x83,0xC7,0xF9,0x93,0xE7,0x80,0x99,0x99,0x99,0x99,0x99,0x9F,0xE7,0x99,0x99,0x94,0xC3,0x99,0xF3,0x8F,0xE7,0xF1,0xC4,0x80,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x1C,0x00,0x00,0x00,0xFF,0x06,0x30,0x67,0x00,0x30,0x0C,0x3C,0x18,0x00,0x00,0x00,0x18,0x66,0x18,0x30,0x06,0x7F,0x06,0x66,0x18,0x66,0x06,0x00,0x00,0x30,0x7E,0x0C,0x18,0x60,0x66,0x66,0x60,0x66,0x60,0x60,0x66,0x66,0x18,0x0C,0x78,0x60,0x63,0x6E,0x66,0x60,0x66,0x78,0x06,0x18,0x66,0x66,0x7F,0x3C,0x18,0x30,0x30,0x0C,0x0C,0x18,0x00,0x60,0x3E,0x66,0x60,0x66,0x7E,0x18,0x66,0x66,0x18,0x06,0x78,0x18,0x7F,0x66,0x66,0x66,0x66,0x60,0x3C,0x18,0x66,0x66,0x7F,0x18,0x66,0x18,0x18,0x18,0x18,0x6E,0x7F,0x1F,0xFF,0xF8,0x1F,0xFF,0xF8,0x1F,0xFF,0xF8,0xFF,0x0F,0xF0,0x07,0xE0,0x0F,0xF0,0x1F,0xF8,0x00,0x00,0x00,0x0F,0x0F,0x0F,0x0F,0xF0,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xF9,0xCF,0x98,0xFF,0xCF,0xF3,0xC3,0xE7,0xFF,0xFF,0xFF,0xE7,0x99,0xE7,0xCF,0xF9,0x80,0xF9,0x99,0xE7,0x99,0xF9,0xFF,0xFF,0xCF,0x81,0xF3,0xE7,0x9F,0x99,0x99,0x9F,0x99,0x9F,0x9F,0x99,0x99,0xE7,0xF3,0x87,0x9F,0x9C,0x91,0x99,0x9F,0x99,0x87,0xF9,0xE7,0x99,0x99,0x80,0xC3,0xE7,0xCF,0xCF,0xF3,0xF3,0xE7,0xFF,0x9F,0xC1,0x99,0x9F,0x99,0x81,0xE7,0x99,0x99,0xE7,0xF9,0x87,0xE7,0x80,0x99,0x99,0x99,0x99,0x9F,0xC3,0xE7,0x99,0x99,0x80,0xE7,0x99,0xE7,0xE7,0xE7,0xE7,0x91,0x80,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x0E,0x00,0x00,0x00,0x66,0x7C,0x66,0x66,0x00,0x18,0x18,0x66,0x18,0x18,0x00,0x18,0x30,0x66,0x18,0x60,0x66,0x06,0x66,0x66,0x18,0x66,0x66,0x18,0x18,0x18,0x00,0x18,0x00,0x66,0x66,0x66,0x66,0x6C,0x60,0x60,0x66,0x66,0x18,0x6C,0x6C,0x60,0x63,0x66,0x66,0x60,0x3C,0x6C,0x66,0x18,0x66,0x3C,0x77,0x66,0x18,0x60,0x30,0x06,0x0C,0x18,0x00,0x66,0x66,0x66,0x60,0x66,0x60,0x18,0x3E,0x66,0x18,0x06,0x6C,0x18,0x6B,0x66,0x66,0x7C,0x3E,0x60,0x06,0x18,0x66,0x3C,0x3E,0x3C,0x3E,0x30,0x18,0x18,0x18,0x00,0x30,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x1C,0x38,0x00,0x00,0x07,0xE0,0x3F,0xFC,0x00,0x00,0x00,0x0F,0x0F,0x0F,0x0F,0xF0,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x99,0x83,0x99,0x99,0xFF,0xE7,0xE7,0x99,0xE7,0xE7,0xFF,0xE7,0xCF,0x99,0xE7,0x9F,0x99,0xF9,0x99,0x99,0xE7,0x99,0x99,0xE7,0xE7,0xE7,0xFF,0xE7,0xFF,0x99,0x99,0x99,0x99,0x93,0x9F,0x9F,0x99,0x99,0xE7,0x93,0x93,0x9F,0x9C,0x99,0x99,0x9F,0xC3,0x93,0x99,0xE7,0x99,0xC3,0x88,0x99,0xE7,0x9F,0xCF,0xF9,0xF3,0xE7,0xFF,0x99,0x99,0x99,0x9F,0x99,0x9F,0xE7,0xC1,0x99,0xE7,0xF9,0x93,0xE7,0x94,0x99,0x99,0x83,0xC1,0x9F,0xF9,0xE7,0x99,0xC3,0xC1,0xC3,0xC1,0xCF,0xE7,0xE7,0xE7,0xFF,0xCF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x07,0x00,0x18,0x00,0x66,0x18,0x46,0x3F,0x00,0x0C,0x30,0x00,0x00,0x18,0x00,0x18,0x60,0x3C,0x7E,0x7E,0x3C,0x06,0x3C,0x3C,0x18,0x3C,0x3C,0x00,0x18,0x0E,0x00,0x70,0x18,0x3C,0x66,0x7C,0x3C,0x78,0x7E,0x60,0x3C,0x66,0x3C,0x38,0x66,0x7E,0x63,0x66,0x3C,0x60,0x0E,0x66,0x3C,0x18,0x3C,0x18,0x63,0x66,0x18,0x7E,0x3C,0x03,0x3C,0x18,0xFF,0x3C,0x3E,0x7C,0x3C,0x3E,0x3C,0x18,0x06,0x66,0x3C,0x06,0x66,0x3C,0x63,0x66,0x3C,0x60,0x06,0x60,0x7C,0x0E,0x3E,0x18,0x36,0x66,0x0C,0x7E,0x0E,0x18,0x70,0x00,0x10,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x03,0xC0,0x7F,0xFE,0x00,0x00,0x00,0x0F,0x0F,0x0F,0x0F,0xF0,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xE7,0xFF,0x99,0xE7,0xB9,0xC0,0xFF,0xF3,0xCF,0xFF,0xFF,0xE7,0xFF,0xE7,0x9F,0xC3,0x81,0x81,0xC3,0xF9,0xC3,0xC3,0xE7,0xC3,0xC3,0xFF,0xE7,0xF1,0xFF,0x8F,0xE7,0xC3,0x99,0x83,0xC3,0x87,0x81,0x9F,0xC3,0x99,0xC3,0xC7,0x99,0x81,0x9C,0x99,0xC3,0x9F,0xF1,0x99,0xC3,0xE7,0xC3,0xE7,0x9C,0x99,0xE7,0x81,0xC3,0xFC,0xC3,0xE7,0x00,0xC3,0xC1,0x83,0xC3,0xC1,0xC3,0xE7,0xF9,0x99,0xC3,0xF9,0x99,0xC3,0x9C,0x99,0xC3,0x9F,0xF9,0x9F,0x83,0xF1,0xC1,0xE7,0xC9,0x99,0xF3,0x81,0xF1,0xE7,0x8F,0xFF,0xEF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x60,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x18,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x01,0x80,0xFF,0xFF,0x00,0x00,0x00,0x0F,0x0F,0x0F,0x0F,0xF0,0xF0,0xF0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE7,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x83,0xFF,0xFF,0xC3,0xFF,0xFF,0xFF,0xFF,0xFF,0x9F,0xF9,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x87,0xFF,0xFF,0xE7,0xFF,0xFF,0xFF,
};

void setup()
{
  noInterrupts();                   // disable interrupts before messing around with timer registers

  DDRC  = 0b00000000;               // PORTC is always input
  PORTC = 0b00000000;
  DDRD  = 0b11111111;               // PORTD is always output
  PORTD = 0b00000000;
  DDRB  = 0b00111100;               // B0-1: terminal input bits 0-1, B2: VSYNC (timer1), B3: 74165 /PL (timer2 or by hand???), B4: HSync by hand inside ISR
  PORTB = 0b00011000;               // HSYNC=1, /PE=1

  GTCCR = 0b10000011;               // set TSM, PSRSYNC und PSRASY to correlate all 3 timers

  // *****************************
  // ***** Timer0: VGA HSYNC *****
  // *****************************
  TCNT0  = 68;                       // align VSYNC and HSYNC pulses
  TCCR0A = (1 << WGM01) | (0 << WGM00);   // mode 2: Clear Timer on Compare Match (CTC)
  TCCR0B = (0 << WGM02) | (0 << CS02) | (1 << CS01) | (0 << CS00); // x8 prescaler -> 0.5Âµs
  OCR0A  = 95;                      // 95, 79, 16MHz: 63, compare match register A (TOP) -> 32Âµs
  TIMSK0 = (1 << OCIE0A);           // Output Compare Match A Interrupt Enable (not working: TOIE1 with ISR TIMER0_TOIE1_vect because it is already defined by timing functions)

  // *****************************
  // ***** Timer1: VGA VSYNC *****
  // *****************************
  TCNT1  = 0;
  TCCR1A = (1 << COM1B1) | (1 << COM1B0) | (1 << WGM11) | (1 << WGM10); // mode 15 (Fast PWM), set OC1B on Compare Match, clear OC1B at BOTTOM, controlling OC1B pin 10
  TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS12) | (0 << CS11) | (1 << CS10); // x1024 prescaler -> 64Âµs
  OCR1A  = 389;                     // 389, 324, 16MHz: 259, compare match register A (TOP) -> 16.64ms
  OCR1B  = 0;                       // compare match register B -> 64Âµs
  TIMSK1 = (1 << TOIE1);            // enable timer overflow interrupt setting vlines = 0

  // ************************************************
  // ***** Timer2: only used for jitter control *****
  // ************************************************
  TCNT2  = 0;
  TCCR2A = (0<<COM2A1) | (0<<COM2A0) | (1<<WGM21) | (1<<WGM20); // mode 7: Fast PWM, COM2A0=0: normal port HIGH, COM2A0=1: Toggle OC2A pin 11 on Compare Match
  TCCR2B = (1<<WGM22) | (0<<CS22) | (0<<CS21) | (1<<CS20) ;     // set x0 prescaler -> 62.5ns;
  OCR2A  = 7;                   // compare match register A (TOP) -> 250ns
  TIMSK2 = 0;                   // no interrupts here

  GTCCR = 0;                        // clear TSM => all timers start synchronously
  interrupts();

  UCSR0B = 0;                       // brute-force the USART off just in case...

  memset((void*)vram, 32, WIDTH * HEIGHT);   // clear the entire VRAM
}

void loop()
{  
  if ((frames & 63) == 32) if (col < WIDTH) vram[row][col] |= 0b10000000;
  if ((frames & 63) == 0) if (col < WIDTH) vram[row][col] &= 0b01111111;

  if (regout != regin)                            // was a character received
  {
    if (col < WIDTH) vram[row][col] &= 0b01111111;   // restore character beneath the cursor BEFORE a possible scrolling happens
    do ProcessChar(reg[regout++]); while (regout != regin);  // process the character
  }
}

int main() { setup(); while (true) loop(); }      // enforce main() loop w/o serial handler

ISR(TIMER1_OVF_vect) { vline = 0; frames++; }     // timer1 overflow interrupt resets vline at HSYNC

// *****************************************************************
// *****                                                       *****
// ***** ANSI Terminal Implementation (add new functions here) *****
// *****                                                       *****
// *****************************************************************
void ProcessChar(byte inbyte)                    // processes a character (accepts some VT52/GEMDOS ESC sequences, control chars, normal chars)
{
  static byte escvalid = 0;                // Number of valid characters in escbuffer[]
  static byte escbuffer[5] = { 0,0,0,0,0 };

  frames = 30;                                   // make cursor invisible for a very short time after receiving a character

  if (escvalid > 4) escvalid = 0;                // unverarbeitbare ESC-Sequenzen lÃ¶schen und dieses Zeichen normal verarbeiten
  if (inbyte == 27) { escvalid = 1; return; }    // neue ESC sequence starten

  if (escvalid > 0)                              // ES IST BEREITS EIN ESC AKTIV
  {
    if (escvalid < 2)
    {
      if (inbyte == '[') escvalid++;             // als 2. Zeichen MUSS '[' kommen
      else escvalid = 0;
    }
    else                                         // es wurde bereits '\e[' korrekt empfangen...
    {
      escbuffer[escvalid++] = inbyte;            // ein weiteres Zeichen hinzufÃ¼gen
      switch (inbyte)                            // FÃ¼r jede ESC sequence muss geprÃ¼ft werden, ob damit der Befehl komplett ist
      {
        case 'S':
          memset((void*)&vram[start][0], 32, WIDTH);
          start++; if (start > HEIGHT-1) start = 0;
          row++; if (row > HEIGHT-1) row = 0;
          break;
        case 'T':
          start--; if (start < 0) start = HEIGHT-1;
          row--; if (row < 0) row = HEIGHT-1;
          memset((void*)&vram[start][0], 32, WIDTH);
          break;
        case 'A':                                // move cursor up
        {
          byte anz;
          if (escvalid > 4) { anz = (escbuffer[2] - 48) << 1; anz += (anz << 2) + escbuffer[3] - 48; }
          else if (escvalid == 4) anz = escbuffer[2] - 48; else anz = 1;
          for (byte i = 0; i < anz; i++) if (row != start) { row--; if (row < 0) row = HEIGHT-1; }
          escvalid = 0; break;
        }
        case 'B':                                // move cursor down
        {
          byte anz;
          if (escvalid > 4) { anz = (escbuffer[2] - 48) << 1; anz += (anz << 2) + escbuffer[3] - 48; }
          else if (escvalid == 4) anz = escbuffer[2] - 48; else anz = 1;
          for (byte i = 0; i < anz; i++) { byte oldrow = row; row++; if (row > HEIGHT-1) row = 0; if (row == start) row = oldrow; }
          escvalid = 0; break;
        }
        case 'C':                                // move cursor right
        {
          byte anz;
          if (escvalid > 4) { anz = (escbuffer[2] - 48) << 1; anz += (anz << 2) + escbuffer[3] - 48; }
          else if (escvalid == 4) anz = escbuffer[2] - 48; else anz = 1;
          for (byte i = 0; i < anz; i++) if (col < WIDTH-1) col++;
          escvalid = 0; break;
        }
        case 'D':                                // move cursor left
        {
          byte anz;
          if (escvalid > 4) { anz = (escbuffer[2] - 48) << 1; anz += (anz << 2) + escbuffer[3] - 48; }
          else if (escvalid == 4) anz = escbuffer[2] - 48; else anz = 1;
          for (byte i = 0; i < anz; i++) if (col > 0) col--;
          escvalid = 0; break;
        }
        case 'G':                                // move cursor to an absolute x position (left border: 1)
        {
          byte anz;
          if (escvalid > 4) { anz = (escbuffer[2] - 48) << 1; col = min(WIDTH-1, max(0, (anz << 2) + anz + escbuffer[3] - 48 - 1)); }
          else if (escvalid == 4) { col = min(WIDTH-1, max(0, escbuffer[2] - 48 - 1)); }
          else col = 0;
          escvalid = 0; break;
        }
        case 'd':                                // move cursor to an absolute x position (left border: 1)
        {
          byte anz;
          if (escvalid > 4)
          {
            anz = (escbuffer[2] - 48) << 1;
            row = start + min(HEIGHT-1, max(0, (anz << 2) + anz + escbuffer[3] - 48 - 1));
            if (row > HEIGHT-1) row -=HEIGHT;
          }
          else if (escvalid == 4)
          {
            row = start + min(HEIGHT-1, max(0, escbuffer[2] - 48 - 1));
            if (row > HEIGHT-1) row -=HEIGHT;
          }
          else row = start;
          escvalid = 0; break;
        }
        case 'H':                                // move cursor to upper left corner
          row = start; col = 0;
          escvalid = 0; break;
        case 'J':                                // clear VRAM from cursor onwards
        {
          memset((void*)&vram[row][col], 32, WIDTH-col);
          byte r = row;
          do { if (++r > HEIGHT-1) r = 0; memset((void*)&vram[r][0], 32, WIDTH); } while (r != start);
          escvalid = 0; break;
        }
        case 'K':                                // clear line from cursor onwards (does not move the cursor)
          memset((void*)&vram[row][col], 32, WIDTH-col);
          escvalid = 0; break;
        case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': break;    // add numbers to ESC sequence
        default: escvalid = 0; break;            // all other chars -> end ESC sequence
      }
    }
  }
  else                                           // NO ESC SEQUENCE => ORDINARY CHARACTER
  {
    switch (inbyte)
    {
      case '\r': col = 0; break;                // Sonderzeichen 'carriage return' abfangen        
      case '\n':                                 // Sonderzeichen 'newline' abfangen
        col = 0;
        if (row < HEIGHT-1) row++; else row=0;
        if (row == start) { memset((void*)&vram[row][0], 32, WIDTH); start++; if (start > HEIGHT-1) start = 0; }
        break;
      case 8:                                   // Sonderzeichen 'BACKSPACE' abfangen
        if (col > 0) vram[row][--col] = 32;
        else if (row != start) { if (row > 0) row--; else row = HEIGHT-1; vram[row][WIDTH-1] = 32; col = WIDTH-1; }
        break;
      default:
        if (inbyte >= 32)                       // start of printable characters
        {
          if (col > WIDTH-1)
          {
            col = 0;
            if (row < HEIGHT-1) row++; else row=0;
            memset((void*)&vram[row][0], 32, WIDTH);
            if (row == start) { start++; if (start > HEIGHT-1) start = 0; }
          }
          vram[row][col++] = inbyte;             // Zeichen im Terminal ausgeben
        }
        break;
    }
  }
}

/*
-----------
MIT License
-----------
Copyright (c) 2021 Carsten Herting
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
