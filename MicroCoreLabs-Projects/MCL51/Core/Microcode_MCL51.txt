//
//
//  File Name   :  Microcode_MCL51.txt
//  Used on     :  MCL51
//  Author      :  Ted Fried, MicroCore Labs
//  Creation    :  1/25/2020
//  Code Type   :  Microcode
//
//   Description:
//   ============
//   
//  Microcode for the MCL51
//
//------------------------------------------------------------------------
//
// Modification History:
// =====================
//
// Revision 1.0 1/25/2020
// Initial revision
//
//
//------------------------------------------------------------------------
//
// Copyright (c) 2020 Ted Fried
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
//------------------------------------------------------------------------

// Microcode and microsequencer notes:
//  

[15:8]=Internal Flags and system signals  [7:0]=Actual PSW register from the BIU
    ** Flags must be written to the PSW through the BIU - User could access PSW by address at any time
    
assign eu_flags_r[15]       =  eu_add_carry
assign eu_flags_r[14]       =  eu_add_aux_carry
assign eu_flags_r[13]       =  eu_add_carry16
assign eu_flags_r[12]       =  
assign eu_flags_r[11]       = 
assign eu_flags_r[10]       =  eu_add_overflow
assign eu_flags_r[9]        =  
assign eu_flags_r[8]        =  BIU_INTERRUPT 

assign eu_flags_r[7]        =  BIU_SFR_PSW[7]   // C
assign eu_flags_r[6]        =  BIU_SFR_PSW[6]   // AC
assign eu_flags_r[5]        =  BIU_SFR_PSW[5]   // F0
assign eu_flags_r[4]        =  BIU_SFR_PSW[4]   // RS1
assign eu_flags_r[3]        =  BIU_SFR_PSW[3]   // RS0
assign eu_flags_r[2]        =  BIU_SFR_PSW[2]   // Overflow
assign eu_flags_r[1]        =  BIU_INTR         // Interrupt from the BIU
assign eu_flags_r[0]        =  BIU_SFR_PSW[0]   // Parity



BIU Strobes
-------------
// Signals from the EU to request BIU processing
//  Only asserted for one clock cycle and cause BIU to take immediate action.
//  

eu_biu_address_code   = eu_biu_strobe[6:4]; 
                            0=Program code space    
                            1=Direct Data space  
                            2=Indirect Data space  
                            3=SFR or Bit address?

eu_biu_strobe         = eu_biu_strobe[2:0];   
                            0=idle  
                            1=write BIU_DATAOUT to address in r3  
                            2=read address in r3 into BIU_RETURN_DATA
                            3=Global Interrupt Disable
                            4=Global Interrupt Enable
                                                        

EU Registers
--------------

Destination                 Operand0                    Operand1
-----------------------------------------------------------------------------------------------
0   r0                      0   r0                      0   r0
1   r1                      1   r1                      1   r1
2   r2                      2   r2                      2   r2
3   r3                      3   r3                      3   r3
4   BIU_Dataout             4   00,BIU_Return_Data      4   00,SP
5   Dummy                   5   {eu_flags_r}            5   
6   BIU_Strobe              6   00,ACC                  6   DPTR
7   IP                      7   IP                      7   Opcode Immediate[15:0]  
                            8+  16'h0000


EU Opcodes
-----------
0x1 - JUMP
----------------
Bits[31:28] : 0x1
Bits[27:24] : CALL  1=Push next IP address to call stack
Bits[22:20] : Jump Source:      
                0x0=Immediate[12:0] 
                0x1={4'h0 & code_byte}                                  -- For initial Jump
                0x2={immediate[xx:0] & code_byte[3:0]}                  -- Addressing modes 
                0x3=Return to CALL stored IP address                    -- CALL Return
                0x4={ 7'h00 , BIU_RETURN_DATA[2:0] }                    -- Bit Mask decoding table


Bits[19:16] : Jump Condition:   
                0x0=Unconditional   
                0x1=Last_ALU_Result!=0      
                0x2=Last_ALU_Result==0
Bits[12:0]  : Immediate[12:0]


0x2 - ADD
0x3 - XOR
0x4 - OR
0x5 - AND
0x6 - Byte swap eu_operand0
0x7 - Shift Right based on type:  { immediate[0] , eu_operand0[7:0] }   
                                  Immedaite = 0 = Eight bit - shift in op0[0],  
                                              1 = Eight bit - shift in PSW_carry
                                              2 = Sixteen bit - shift in eu_add_carry16



# Reset the CPU
p 00 00000 00001 0001
p 01 00000 00001 0000
p 01 00000 00001 000F
# 
#
d 20
#
#
#

# --------------------------------------------------------------------
# --------------------------------------------------------------------
#
#                  MCL51 EU Microcode
#
# --------------------------------------------------------------------
# --------------------------------------------------------------------
#
#
#
# --------------------------------------------------------------------
#
#         Main Microcode Loop at address 0x0100
# 
# Increment the PC, poll for interrupts, then decode opcode
#
# --------------------------------------------------------------------
#
#
# NOP
p 00 00000 00000 0100
p 01 00000 00000 0000
p 01 00000 00000 0000
#
# IP = IP + 1 - Increment the Program Counter
p 00 00000 00000 0101
p 01 00000 00000 2777
p 01 00000 00000 0001
#
# Isolate the interrupt request from the BIU into Dummy
p 00 00000 00000 0102
p 01 00000 00000 5557
p 01 00000 00000 0100
#
# Jump if non-zero to Interrupt Processing code
p 00 00000 00000 0103
p 01 00000 00000 1001
p 01 00000 00000 03A0
#
# Jump-1 to opcode decode
p 00 00000 00000 0104
p 01 00000 00000 1010
p 01 00000 00000 0000
#
#
#
# -----------------------------------------------------
#
# PROCEDURE - FETCH_INDIRECT_BYTE
#
#  Fetch a data byte using Indirect BIU Request
#
# Inputs      r3 = Address  
# Outputs:    r0 = Data fetched
#
#
# -----------------------------------------------------
#
# Strobe BIU to read the this address using Indirect addressing mode
p 00 00000 00000 010A
p 01 00000 00000 4687
p 01 00000 00000 0022
#
# NOP
p 00 00000 00000 010B
p 01 00000 00000 0000
p 01 00000 00000 0000
#
# r0 = BIU_RETURN_DATA
p 00 00000 00000 010C
p 01 00000 00000 4047
p 01 00000 00000 0000
#
# Debounce BIU Strobe
p 00 00000 00000 010D
p 01 00000 00000 5687
p 01 00000 00000 0000
#
# Unconditional Jump to return address
p 00 00000 00000 010E
p 01 00000 00000 1030
p 01 00000 00000 0000
#
#
# -----------------------------------------------------
#
# PROCEDURE - FETCH_DIRECT_BYTE
#
#  For Rx accesses, the RS[1:0] bits are prepended to the addresses to select the register bank.
#  - Direct BIU accesses is ok to use because Rx address is 0x00-0x1F
#
# Inputs      r3 = Address
# Outputs:    r0 = Data fetched
#
# CALL to:   0x0110 for FETCH_IMMEDIATE_DIRECT using opcode address
#            0x0114 for FETCH_Rx_BYTE  
#            0x0115 for FETCH_Ri_POINTER  
#            0x0117 for FETCH_DIRECT_BYTE
#
# -----------------------------------------------------
#
# IP = IP + 1 - Increment the Program Counter
p 00 00000 00000 0110
p 01 00000 00000 2777
p 01 00000 00000 0001
#
# NOP
p 00 00000 00000 0111
p 01 00000 00000 0000
p 01 00000 00000 0000
#
# r3 = BIU_DATAOUT  - Fetch the contents of the address contained in BIU_RETURN_DATA
p 00 00000 00000 0112
p 01 00000 00000 4347
p 01 00000 00000 0000
#
# Unconditional Jump to the BIU Strobe
p 00 00000 00000 0113
p 01 00000 00000 1000
p 01 00000 00000 0117
#
# r3 = OPCODE_BYTE AND 0x0007 - Isolate the Rx bits from the opcode
p 00 00000 00000 0114
p 01 00000 00000 5347
p 01 00000 00000 0007
#
# r0 = Flags AND 0x0018 - Isolate RS[1:0] from Flags register
p 00 00000 00000 0115
p 01 00000 00000 5057
p 01 00000 00000 0018
#
# r3 = r3 OR r0 - Generate the BIU address for the register Rx
p 00 00000 00000 0116
p 01 00000 00000 4330
p 01 00000 00000 0000
#
# Strobe BIU to read the this address using Direct addressing mode
p 00 00000 00000 0117
p 01 00000 00000 4687
p 01 00000 00000 0012
#
# Unconditional Jump to common FETCH_INDIRECT_BYTE code
p 00 00000 00000 0118
p 01 00000 00000 1000
p 01 00000 00000 010C
#
#
# -----------------------------------------------------
#
# PROCEDURE - WRITEBACK_DIRECT
#
#  Write data in r0 to the Direct address in r3
#
# Inputs:    r0 = Data to be written
#            r3 = Direct Address
#
# Jump to:   0x011B : WRITEBACK_DIRECT_ACC - To write to the Accumulator
#            0x011C : Write to address r3
#
# -----------------------------------------------------
#
# r3 = 0x00E0 - Address of the Accumulator
p 00 00000 00000 011B
p 01 00000 00000 4387
p 01 00000 00000 00E0
#
# BIU_DATAOUT = r0
p 00 00000 00000 011C
p 01 00000 00000 4407
p 01 00000 00000 0000
#
# Strobe BIU to write the this address using Direct addressing mode
p 00 00000 00000 011D
p 01 00000 00000 4687
p 01 00000 00000 0011
#
# Debounce BIU Strobe
p 00 00000 00000 011E
p 01 00000 00000 5687
p 01 00000 00000 0000
#
# Unconditional Jump to return address
p 00 00000 00000 011F
p 01 00000 00000 1030
p 01 00000 00000 0000
#
#
# -----------------------------------------------------
#
# PROCEDURE - WRITEBACK_INDIRECT
#
#  Write data in r0 to the Indirect address in r3
#
# Inputs:    r0 = Data to be written
#            r3 = Direct Address
#
# -----------------------------------------------------
#
# BIU_DATAOUT = r0
p 00 00000 00000 0122
p 01 00000 00000 4407
p 01 00000 00000 0000
#
# Strobe BIU to write the this address using Indirect addressing mode
p 00 00000 00000 0123
p 01 00000 00000 4687
p 01 00000 00000 0021
#
# Debounce BIU Strobe
p 00 00000 00000 0124
p 01 00000 00000 5687
p 01 00000 00000 0000
#
# Unconditional Jump to return address
p 00 00000 00000 0125
p 01 00000 00000 1030
p 01 00000 00000 0000
#
#
# -----------------------------------------------------
#
# PROCEDURE - FETCH_Ri_BYTE
#
#  Fetch the Indirect Data held in Ri
#
# Input:     r3 = bit0 points to R0 or R1
# Output:    r0 = Fetched data
#
# -----------------------------------------------------
#
# r3 = OPCODE_BYTE AND 0x0001 - Isolate the Rx bits from the opcode
p 00 00000 00000 0128
p 01 00000 00000 5347
p 01 00000 00000 0001
#
# Call FETCH_Ri_POINTER - Calculate the Address
p 00 00000 00000 0129
p 01 00000 00000 1100
p 01 00000 00000 0115
#
# r3 = r0  - New adadress is the address contained in Ri
p 00 00000 00000 012A
p 01 00000 00000 4380
p 01 00000 00000 0000
#
# Call FETCH_INDIRECT_BYTE
p 00 00000 00000 012B
p 01 00000 00000 1100
p 01 00000 00000 010A
#
# Unconditional Jump to return address
p 00 00000 00000 012C
p 01 00000 00000 1030
p 01 00000 00000 0000
#
#
# -----------------------------------------------------
#
# PROCEDURE - FETCH_IMMEDIATE
#
# Outputs:    BIU_RETURN_DATA = Next instruction byte
#
# -----------------------------------------------------
#
# IP = IP + 1 - Increment the Program Counter
p 00 00000 00000 012E
p 01 00000 00000 2777
p 01 00000 00000 0001
#
# Unconditional Jump to return address
p 00 00000 00000 012F
p 01 00000 00000 1030
p 01 00000 00000 0000
#
#
# -----------------------------------------------------
# -----------------------------------------------------
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0xE5 - MOV A,(Direct)
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 0130
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0131
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 0132
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0xE2-0xE3 & 0xE6-0xE7 - MOV A,@Ri
#
# Call FETCH_Ri_BYTE
p 00 00000 00000 0133
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0134
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 0135
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0xE8-0xEF - MOV A,Rx
#
# Call FETCH_Rx_BYTE
p 00 00000 00000 0136
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0137
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 0138
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x45 - ORL A,(Direct)
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 0139
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r0 = ACC or r0
p 00 00000 00000 013A
p 01 00000 00000 4060
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 013B
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 013C
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x46-0x47 - ORL A,@Ri
#

# Call FETCH_Ri_BYTE
p 00 00000 00000 013D
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# Jump unconditional to common code
p 00 00000 00000 013E
p 01 00000 00000 1000
p 01 00000 00000 013A
#
#
# -----------------------------------------------------
#
# 0x48-0x4F - ORL A,Rx
#
# Call FETCH_Rx_BYTE
p 00 00000 00000 013F
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# Jump unconditional to common code
p 00 00000 00000 0140
p 01 00000 00000 1000
p 01 00000 00000 013A
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x55 - ANL A,(Direct)
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 0141
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r0 = ACC and r0
p 00 00000 00000 0142
p 01 00000 00000 5060
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0143
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 0144
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x56-0x57 - ANL A,@Ri
#

# Call FETCH_Ri_BYTE
p 00 00000 00000 0145
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# Jump unconditional to common code
p 00 00000 00000 0146
p 01 00000 00000 1000
p 01 00000 00000 0142
#
#
# -----------------------------------------------------
#
# 0x58-0x5F - ANL A,Rx
#
# Call FETCH_Rx_BYTE
p 00 00000 00000 0147
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# Jump unconditional to common code
p 00 00000 00000 0148
p 01 00000 00000 1000
p 01 00000 00000 0142
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x65 - XRL A,(Direct)
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 0149
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r0 = ACC xor r0
p 00 00000 00000 014A
p 01 00000 00000 3060
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 014B
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 014C
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x66-0x67 - XRL A,@Ri
#
# Call FETCH_Ri_BYTE
p 00 00000 00000 014D
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# Jump unconditional to common code
p 00 00000 00000 014E
p 01 00000 00000 1000
p 01 00000 00000 014A
#
#
# -----------------------------------------------------
#
# 0x68-0x6F - XRL A,Rx
#
# Call FETCH_Rx_BYTE
p 00 00000 00000 014F
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# Jump unconditional to common code
p 00 00000 00000 0150
p 01 00000 00000 1000
p 01 00000 00000 014A
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
#
# 0xF5 - MOV (Direct),A
#
# Call FETCH_IMMEDIATE_DIRECT - Calculate the Address
p 00 00000 00000 0151
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r0 = ACC
p 00 00000 00000 0152
p 01 00000 00000 4067
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 0153
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 0154
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0xF2-0xF3 & 0xF6-0xF7 - MOV @Ri,A
#
# Call FETCH_Ri_BYTE
p 00 00000 00000 0155
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# r0 = ACC
p 00 00000 00000 0156
p 01 00000 00000 4067
p 01 00000 00000 0000
#
# Call WRITEBACK_INDIRECT
p 00 00000 00000 0157
p 01 00000 00000 1100
p 01 00000 00000 0122
#
# Jump unconditional to Main Loop
p 00 00000 00000 0158
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0xF8-0xFF - MOV Rx,A
#
# Call FETCH_Rx_BYTE - Calculate the Address
p 00 00000 00000 0159
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# r0 = ACC
p 00 00000 00000 015A
p 01 00000 00000 4067
p 01 00000 00000 0000
#
# Call WRITEBACK_INDIRECT
p 00 00000 00000 015B
p 01 00000 00000 1100
p 01 00000 00000 0122
#
# Jump unconditional to Main Loop
p 00 00000 00000 015C
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0xA6-0xA7 - MOV @Ri,(Direct)
#
# Call FETCH_Ri_BYTE
p 00 00000 00000 015D
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# r2 = r3 - Store the Ri Address 
p 00 00000 00000 015E
p 01 00000 00000 4237
p 01 00000 00000 0000
#
# Call FETCH_IMMEDIATE_DIRECT - Calculate the Address
p 00 00000 00000 015F
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r3 = r2 - Restore the Ri Address 
p 00 00000 00000 0160
p 01 00000 00000 4327
p 01 00000 00000 0000
#
# Call WRITEBACK_INDIRECT
p 00 00000 00000 0161
p 01 00000 00000 1100
p 01 00000 00000 0122
#
# Jump unconditional to Main Loop
p 00 00000 00000 0162
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0xA8-0xAF - MOV Rx,(Direct)
#
# Call FETCH_Rx_BYTE - Calculate the Address
p 00 00000 00000 0163
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# r2 = r3 - Store the Rx Address 
p 00 00000 00000 0164
p 01 00000 00000 4237
p 01 00000 00000 0000
#
# Call FETCH_IMMEDIATE_DIRECT - Calculate the Address
p 00 00000 00000 0165
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r3 = r2 - Restore the Rx Address 
p 00 00000 00000 0166
p 01 00000 00000 4327
p 01 00000 00000 0000
#
# Call WRITEBACK_INDIRECT
p 00 00000 00000 0167
p 01 00000 00000 1100
p 01 00000 00000 0122
#
# Jump unconditional to Main Loop
p 00 00000 00000 0168
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x05 - INC (Direct)
#
# Call FETCH_IMMEDIATE_DIRECT 
p 00 00000 00000 0169
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r0 = r0 + 1
p 00 00000 00000 016A
p 01 00000 00000 2007
p 01 00000 00000 0001
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 016B
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 016C
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x06-0x07 - INC @Ri
#
# Call FETCH_Ri_BYTE
p 00 00000 00000 016D
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# r0 = r0 + 1
p 00 00000 00000 016E
p 01 00000 00000 2007
p 01 00000 00000 0001
#
# Call WRITEBACK_INDIRECT
p 00 00000 00000 016F
p 01 00000 00000 1100
p 01 00000 00000 0122
#
# Jump unconditional to Main Loop
p 00 00000 00000 0170
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x08-0x0F - INC Rx
#
# Call FETCH_Rx_BYTE
p 00 00000 00000 0171
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# r0 = r0 + 1
p 00 00000 00000 0172
p 01 00000 00000 2007
p 01 00000 00000 0001
#
# Call WRITEBACK_INDIRECT
p 00 00000 00000 0173
p 01 00000 00000 1100
p 01 00000 00000 0122
#
# Jump unconditional to Main Loop
p 00 00000 00000 0174
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x04 - INC A
#
# r0 = ACC + 1
p 00 00000 00000 0175
p 01 00000 00000 2067
p 01 00000 00000 0001
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0176
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 0177
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x14 - DEC A
#
# r0 = ACC - 1
p 00 00000 00000 0178
p 01 00000 00000 2067
p 01 00000 00000 FFFF
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0179
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 017A
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x15 - DEC (Direct)
#
# Call FETCH_IMMEDIATE_DIRECT 
p 00 00000 00000 017B
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r0 = r0 - 1
p 00 00000 00000 017C
p 01 00000 00000 2007
p 01 00000 00000 FFFF
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 017D
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 017E
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x16-0x17 - DEC @Ri
#
# Call FETCH_Ri_BYTE
p 00 00000 00000 017F
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# r0 = r0 - 1
p 00 00000 00000 0180
p 01 00000 00000 2007
p 01 00000 00000 FFFF
#
# Call WRITEBACK_INDIRECT
p 00 00000 00000 0181
p 01 00000 00000 1100
p 01 00000 00000 0122
#
# Jump unconditional to Main Loop
p 00 00000 00000 0182
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x18-0x1F - DEC Rx
#
# Call FETCH_Rx_BYTE
p 00 00000 00000 0183
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# r0 = r0 - 1
p 00 00000 00000 0184
p 01 00000 00000 2007
p 01 00000 00000 FFFF
#
# Call WRITEBACK_INDIRECT
p 00 00000 00000 0185
p 01 00000 00000 1100
p 01 00000 00000 0122
#
# Jump unconditional to Main Loop
p 00 00000 00000 0186
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x85 - MOV (Direct_Src),(Direct_Dest)
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 0187
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# Call FETCH_IMMEDIATE - Get next instruction byte
p 00 00000 00000 0188
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r3 = BIU_RETURN_DATA 
p 00 00000 00000 0189
p 01 00000 00000 4347
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 018A
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 018B
p 01 00000 00000 1000
p 01 00000 00000 0101
#


#
# -----------------------------------------------------
#
# 0x86-0x87 - MOV (Direct),@Ri
#
# Call FETCH_Ri_BYTE
p 00 00000 00000 018D
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# Call FETCH_IMMEDIATE - Get next instruction byte
p 00 00000 00000 018E
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r3 = BIU_RETURN_DATA - Store the destination address
p 00 00000 00000 018F
p 01 00000 00000 4347
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 0190
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 0191
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x88-0x8F - MOV (Direct),Rx
#
# Call FETCH_Rx_BYTE
p 00 00000 00000 0192
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# Jump unconditional to common code
p 00 00000 00000 0193
p 01 00000 00000 1000
p 01 00000 00000 018E
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x74 - MOV A,#Data
#
# Call FETCH_IMMEDIATE 
p 00 00000 00000 0194
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r0 = BIU_RETURN_DATA
p 00 00000 00000 0195
p 01 00000 00000 4047
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0196
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 0197
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x75 - MOV (Direct),#Data
#
# Call FETCH_IMMEDIATE - Get next instruction byte
p 00 00000 00000 0198
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r3 = BIU_RETURN_DATA
p 00 00000 00000 0199 - Store the destination address
p 01 00000 00000 4347
p 01 00000 00000 0000
#
# Call FETCH_IMMEDIATE 
p 00 00000 00000 019A
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r0 = BIU_RETURN_DATA
p 00 00000 00000 019B
p 01 00000 00000 4047
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 019C
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 019D
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x76-0x77 - MOV @Ri,#Data
#
# Call FETCH_Ri_BYTE
p 00 00000 00000 019E
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# Call FETCH_IMMEDIATE 
p 00 00000 00000 019F
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r0 = BIU_RETURN_DATA
p 00 00000 00000 01A0
p 01 00000 00000 4047
p 01 00000 00000 0000
#
# Call WRITEBACK_INDIRECT
p 00 00000 00000 01A1
p 01 00000 00000 1100
p 01 00000 00000 0122
#
# Jump unconditional to Main Loop
p 00 00000 00000 01A2
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x78-0x7F - MOV Rx,#Data
#
# Call FETCH_Rx_BYTE
p 00 00000 00000 01A3
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# Jump unconditional to common code
p 00 00000 00000 01A4
p 01 00000 00000 1000
p 01 00000 00000 019F
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0xC5 - XCH A,(Direct)
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 01A5
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r1 = r0
p 00 00000 00000 01A6
p 01 00000 00000 4107
p 01 00000 00000 0000
#
# r0 = ACC
p 00 00000 00000 01A7
p 01 00000 00000 4067
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 01A8
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# r0 = r1
p 00 00000 00000 01A9
p 01 00000 00000 4017
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 01AA
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 01AB
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0xC6-0xC7 - XCH A,@Ri
#
# Call FETCH_Ri_BYTE
p 00 00000 00000 01AC
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# r1 = r0
p 00 00000 00000 01AD
p 01 00000 00000 4107
p 01 00000 00000 0000
#
# r0 = ACC
p 00 00000 00000 01AE
p 01 00000 00000 4067
p 01 00000 00000 0000
#
# Call WRITEBACK_INDIRECT
p 00 00000 00000 01AF
p 01 00000 00000 1100
p 01 00000 00000 0122
#
# Jump unconditional to common code
p 00 00000 00000 01B0
p 01 00000 00000 1000
p 01 00000 00000 01A9
#
#
# -----------------------------------------------------
#
# 0xC8-0xCF - XCH A,Rx
#
# Call FETCH_Rx_BYTE
p 00 00000 00000 01B1
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# Jump unconditional to common code
p 00 00000 00000 01B2
p 01 00000 00000 1000
p 01 00000 00000 01A6
#
#
# -----------------------------------------------------
#
# 0xD6-0xD7 - XCHD A,@Ri
#
# Call FETCH_Ri_BYTE
p 00 00000 00000 01B3
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# r1 = r0
p 00 00000 00000 01B4
p 01 00000 00000 4107
p 01 00000 00000 0000
#
# r0 = ACC AND 000F
p 00 00000 00000 01B5
p 01 00000 00000 5067
p 01 00000 00000 000F
#
# r2 = r1 AND 00F0
p 00 00000 00000 01B6
p 01 00000 00000 5217
p 01 00000 00000 00F0
#
# r0 = r0 OR r2
p 00 00000 00000 01B7
p 01 00000 00000 4002
p 01 00000 00000 0000
#
# Call WRITEBACK_INDIRECT
p 00 00000 00000 01B8
p 01 00000 00000 1100
p 01 00000 00000 0122
#
# r0 = r1 AND 000F
p 00 00000 00000 01B9
p 01 00000 00000 5017
p 01 00000 00000 000F
#
# r2 = ACC AND 00F0
p 00 00000 00000 01BA
p 01 00000 00000 5267
p 01 00000 00000 00F0
#
# r0 = r0 OR r2
p 00 00000 00000 01BB
p 01 00000 00000 4002
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 01BC
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 01BD
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# PROCEDURE - CALC_FLAGS
#
# Inputs      r2 = Copy of PSW.  Flags can be zeroed or not.
#
#
# -----------------------------------------------------
#
# r3 = Byte-swapped alu_flags - Place the current ALU flags in the lower byte
p 00 00000 00000 01BE
p 01 00000 00000 6357
p 01 00000 00000 0000
#
# r3 = r3 AND 00C4 - Zero the non-flag fields
p 00 00000 00000 01BF
p 01 00000 00000 5337
p 01 00000 00000 00C4
#
# r2 = r2 OR r3 - OR new Flag bits with current PSW SFR
p 00 00000 00000 01C0
p 01 00000 00000 4223
p 01 00000 00000 0000
#
# Unconditional Jump to return address
p 00 00000 00000 01C1
p 01 00000 00000 1030
p 01 00000 00000 0000
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x34 - ADDC A,#Data
#
#
# Call FETCH_IMMEDIATE 
p 00 00000 00000 01C2
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r1 = BIU_RETURN_DATA - Store memory byte in r1 for now
p 00 00000 00000 01C3
p 01 00000 00000 4147
p 01 00000 00000 0000
#
#
# Main ADDC Code
#
# Dummy = PSW AND 0080 - Isolate the PSW Carry bit
p 00 00000 00000 01C4
p 01 00000 00000 5557
p 01 00000 00000 0080
#
# Jump if last alu is zero to ADD code  Should be 1002
p 00 00000 00000 01C5
p 01 00000 00000 1002
p 01 00000 00000 01CA
#
# r0 = ACC + 1
p 00 00000 00000 01C6
p 01 00000 00000 2067
p 01 00000 00000 0001
#
# r2 = PSW AND 003A - Zero the original PSW Flag fields
p 00 00000 00000 01C7
p 01 00000 00000 5257
p 01 00000 00000 003A
#
# Call CALC_FLAGS
p 00 00000 00000 01C8
p 01 00000 00000 1100
p 01 00000 00000 01BE
#
# Unconditional Jump over Flag clearing code below
p 00 00000 00000 01C9
p 01 00000 00000 1000
p 01 00000 00000 01CC
#
#
# Main ADD Code
#
# r2 = PSW AND 003A - Zero the original PSW Flag fields
p 00 00000 00000 01CA
p 01 00000 00000 5257
p 01 00000 00000 003A
#
# r0 = ACC
p 00 00000 00000 01CB
p 01 00000 00000 4067
p 01 00000 00000 0000
#
# r0 = r0 + r1
p 00 00000 00000 01CC
p 01 00000 00000 2001
p 01 00000 00000 0001
#
# Call CALC_FLAGS
p 00 00000 00000 01CD
p 01 00000 00000 1100
p 01 00000 00000 01BE
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 01CE
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# r0 = r2 - Data for the PSW SFR
p 00 00000 00000 01CF
p 01 00000 00000 4027
p 01 00000 00000 0000
#
# r3 = 0x00D0 - Address of the PSW SFR
p 00 00000 00000 01D0
p 01 00000 00000 4387
p 01 00000 00000 00D0
#
# Call WRITEBACK_DIRECT  - Write the PSW back to SFR memory
p 00 00000 00000 01D1
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 01D2
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x24 - ADD A,#Data
#
# Call FETCH_IMMEDIATE 
p 00 00000 00000 01D3
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r1 = BIU_RETURN_DATA - Store memory byte in r1 for now
p 00 00000 00000 01D4
p 01 00000 00000 4147
p 01 00000 00000 0000
#
# Jump unconditional to ADD Code
p 00 00000 00000 01D5
p 01 00000 00000 1000
p 01 00000 00000 01CA
#
#
# -----------------------------------------------------
#
# 0x25 - ADD A,(Direct)
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 01D6
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r1 = r0 - Store memory byte in r1 for now
p 00 00000 00000 01D7
p 01 00000 00000 4107
p 01 00000 00000 0000
#
# Jump unconditional to common code
p 00 00000 00000 01D8
p 01 00000 00000 1000
p 01 00000 00000 01CA
#

# -----------------------------------------------------
#
# 0x28-0x2F - ADD A,Rx
#
# Call FETCH_Rx_BYTE
p 00 00000 00000 01DA
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# Jump unconditional to common code
p 00 00000 00000 01DB
p 01 00000 00000 1000
p 01 00000 00000 01D7
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x35 - ADDC A,(Direct)
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 01DC
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r1 = r0 - Store memory byte in r1 for now
p 00 00000 00000 01DD
p 01 00000 00000 4107
p 01 00000 00000 0000
#
# Jump unconditional to ADDC Code
p 00 00000 00000 01DE
p 01 00000 00000 1000
p 01 00000 00000 01C4
#
#
# -----------------------------------------------------
#
# 0x36-0x37 - ADDC A,@Ri
#
# Call FETCH_Ri_BYTE
p 00 00000 00000 01DF
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# Jump unconditional to common code
p 00 00000 00000 01E0
p 01 00000 00000 1000
p 01 00000 00000 01DD
#
#
# -----------------------------------------------------
#
# 0x38-0x3F - ADDC A,Rx
#
# Call FETCH_Rx_BYTE
p 00 00000 00000 01E1
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# Jump unconditional to common code
p 00 00000 00000 01E2
p 01 00000 00000 1000
p 01 00000 00000 01DD
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x94 - SUBB A,#Data
#
# Call FETCH_IMMEDIATE 
p 00 00000 00000 01E3
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r0 = BIU_RETURN_DATA 
p 00 00000 00000 01E4
p 01 00000 00000 4047
p 01 00000 00000 0000
#
#
# Main SUBB Code
#
# r2 = PSW AND 003A - Zero the running PSW Flag fields
p 00 00000 00000 01E5
p 01 00000 00000 5257
p 01 00000 00000 003A
#
# r0 = r0 XOR 0xFFFF - 1's Compliment
p 00 00000 00000 01E6
p 01 00000 00000 3007
p 01 00000 00000 FFFF
#
# r0 = ACC + r0 
p 00 00000 00000 01E7
p 01 00000 00000 2060
p 01 00000 00000 FFFF
#
# Call CALC_FLAGS
p 00 00000 00000 01E8
p 01 00000 00000 1100
p 01 00000 00000 01BE
#
# Dummy = PSW AND 0080 - Isolate the previous PSW Carry bit
p 00 00000 00000 01E9
p 01 00000 00000 5557
p 01 00000 00000 0080
#
# Jump if last alu is non-zero to writeback the ACC
p 00 00000 00000 01EA
p 01 00000 00000 1001
p 01 00000 00000 01ED
#
# r0 = r0 + 1 - Finish the 2's compliment if there was a Carry
p 00 00000 00000 01EB
p 01 00000 00000 2007
p 01 00000 00000 0001
#
# Call CALC_FLAGS
p 00 00000 00000 01EC
p 01 00000 00000 1100
p 01 00000 00000 01BE
#
# Call WRITEBACK_DIRECT_ACC DONE:
p 00 00000 00000 01ED
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# r0 = r2 XOR 0x00C0 - Invert the Carry and Aux Flags for the PSW SFR
p 00 00000 00000 01EE
p 01 00000 00000 3027
p 01 00000 00000 00C0
#
# r3 = 0x00D0 - Address of the PSW SFR
p 00 00000 00000 01EF
p 01 00000 00000 4387
p 01 00000 00000 00D0
#
# Call WRITEBACK_DIRECT  - Write the PSW back to SFR memory
p 00 00000 00000 01F0
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 01F1
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0xE4 - CLR A
#
# r0 = 0x0000
p 00 00000 00000 01F2
p 01 00000 00000 5080
p 01 00000 00000 0000
#
# Jump unconditional to common code to writeback the Accumulator
p 00 00000 00000 01F3
p 01 00000 00000 1000
p 01 00000 00000 0131
#
#
# -----------------------------------------------------
#
# 0xF4 - CPL A
#
# r0 = A XOR 0xFFFF - Compliment A
p 00 00000 00000 01F4
p 01 00000 00000 3067
p 01 00000 00000 FFFF
#
# Jump unconditional to common code to writeback the Accumulator
p 00 00000 00000 01F5
p 01 00000 00000 1000
p 01 00000 00000 0131
#
#
# -----------------------------------------------------
#
# 0x96-0x97 - SUBB A,@Ri
#
# Call FETCH_Ri_BYTE
p 00 00000 00000 01F6
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# Jump unconditional to common code
p 00 00000 00000 01F7
p 01 00000 00000 1000
p 01 00000 00000 01E5
#
#
# -----------------------------------------------------
#
# 0x98-0x9F - SUBB A,Rx
#
# Call FETCH_Rx_BYTE
p 00 00000 00000 01F8
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# Jump unconditional to common code
p 00 00000 00000 01F9
p 01 00000 00000 1000
p 01 00000 00000 01E5
#
#
# -----------------------------------------------------
#
# 0x26-0x27 - ADD A,@Ri
#
# Call FETCH_Ri_BYTE
p 00 00000 00000 01FA
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# Jump unconditional to common code
p 00 00000 00000 01FB
p 01 00000 00000 1000
p 01 00000 00000 01D7
#
#
# -----------------------------------------------------
#
# 0x95 - SUBB A,(Direct)
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 01FC
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# Jump unconditional to SUBB code
p 00 00000 00000 01FD
p 01 00000 00000 1000
p 01 00000 00000 01E5
#
#
# -----------------------------------------------------
#
# 0xB3 - CPL C
#
# r0 = PSW XOR 0x0080 - Compliment C Flag
p 00 00000 00000 01FF
p 01 00000 00000 3057
p 01 00000 00000 0080
#
# Jump unconditional to common code to writeback the Flags
p 00 00000 00000 0200
p 01 00000 00000 1000
p 01 00000 00000 01EF
#
#
# -----------------------------------------------------
#
# 0xC3 - CLR C
#
# r0 = PSW AND 0xFF7F - Clear C Flag
p 00 00000 00000 0201
p 01 00000 00000 5057
p 01 00000 00000 FF7F
#
# Jump unconditional to common code to writeback the Flags
p 00 00000 00000 0202
p 01 00000 00000 1000
p 01 00000 00000 01EF
#
# -----------------------------------------------------
#
# 0xD3 - SETB C
#
# r0 = PSW OR 0x0080 - Set C Flag
p 00 00000 00000 0203
p 01 00000 00000 4057
p 01 00000 00000 0080
#
# Jump unconditional to common code to writeback the Flags
p 00 00000 00000 0204
p 01 00000 00000 1000
p 01 00000 00000 01EF
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x44 - ORL A,#Data
#
# Call FETCH_IMMEDIATE 
p 00 00000 00000 0205
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r0 = BIU_RETURN_DATA - Store memory byte in r1 for now
p 00 00000 00000 0206
p 01 00000 00000 4047
p 01 00000 00000 0000
#
# Jump unconditional to common code
p 00 00000 00000 0207
p 01 00000 00000 1000
p 01 00000 00000 013A
#
#
# -----------------------------------------------------
#
# 0x54 - ANL A,#Data
#
# Call FETCH_IMMEDIATE 
p 00 00000 00000 0208
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r0 = BIU_RETURN_DATA - Store memory byte in r1 for now
p 00 00000 00000 0209
p 01 00000 00000 4047
p 01 00000 00000 0000
#
# Jump unconditional to common code
p 00 00000 00000 020A
p 01 00000 00000 1000
p 01 00000 00000 0142
#
#
# -----------------------------------------------------
#
# 0x64 - XRL A,#Data
#
# Call FETCH_IMMEDIATE 
p 00 00000 00000 020B
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r0 = BIU_RETURN_DATA - Store memory byte in r1 for now
p 00 00000 00000 020C
p 01 00000 00000 4047
p 01 00000 00000 0000
#
# Jump unconditional to common code
p 00 00000 00000 020D
p 01 00000 00000 1000
p 01 00000 00000 014A
#
#
# -----------------------------------------------------
#
# 0x43 - ORL (Direct),#Data
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 020E
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# Call FETCH_IMMEDIATE 
p 00 00000 00000 020F
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r0 = BIU_RETURN_DATA OR r0
p 00 00000 00000 0210
p 01 00000 00000 4040
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 0211
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 0212
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x53 - ANL (Direct),#Data
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 0213
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# Call FETCH_IMMEDIATE 
p 00 00000 00000 0214
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r0 = BIU_RETURN_DATA AND r0
p 00 00000 00000 0215
p 01 00000 00000 5040
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 0216
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 0217
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x63 - XRL (Direct),#Data
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 0218
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# Call FETCH_IMMEDIATE 
p 00 00000 00000 0219
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r0 = BIU_RETURN_DATA XOR r0
p 00 00000 00000 021A
p 01 00000 00000 3040
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 021B
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 021C
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x42 - ORL (Direct),A
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 021D
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r0 = ACC OR r0
p 00 00000 00000 021E
p 01 00000 00000 4060
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 021F
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 0220
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x52 - ANL (Direct),A
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 0221
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r0 = ACC AND r0
p 00 00000 00000 0222
p 01 00000 00000 5060
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 0223
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 0224
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x62 - XRL (Direct),A
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 0225
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r0 = ACC XOR r0
p 00 00000 00000 0226
p 01 00000 00000 3060
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 0227
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 0228
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0xE0 - MOVX A,@DPTR
#
# r3 = DPTR
p 00 00000 00000 0229
p 01 00000 00000 4386
p 01 00000 00000 0000
#
# Call FETCH_INDIRECT_BYTE
p 00 00000 00000 022A
p 01 00000 00000 1100
p 01 00000 00000 010A
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 022B
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 022C
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0xF0 - MOVX @DPTR,A
#
# r3 = DPTR
p 00 00000 00000 022D
p 01 00000 00000 4386
p 01 00000 00000 0000
#
# r0 = ACC
p 00 00000 00000 022E
p 01 00000 00000 4067
p 01 00000 00000 0000
#
# Call WRITEBACK_INDIRECT
p 00 00000 00000 022F
p 01 00000 00000 1100
p 01 00000 00000 0122
#
# Jump unconditional to Main Loop
p 00 00000 00000 0230
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x90 - MOVX DPTR,#Data-16
#
# Call FETCH_IMMEDIATE - Get next instruction byte for DPTR[15:8]
p 00 00000 00000 0231
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r0 = BIU_RETURN_DATA
p 00 00000 00000 0232
p 01 00000 00000 4047
p 01 00000 00000 0000
#
# r3 = 0x0083 - Address of SFR DPTR[15:8]
p 00 00000 00000 0233
p 01 00000 00000 4387
p 01 00000 00000 0083
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 0234
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Call FETCH_IMMEDIATE - Get next instruction byte for DPTR[7:0]
p 00 00000 00000 0235
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r0 = BIU_RETURN_DATA
p 00 00000 00000 0236
p 01 00000 00000 4047
p 01 00000 00000 0000
#
# r3 = 0x0082 - Address of SFR DPTR[7:0]
p 00 00000 00000 0237
p 01 00000 00000 4387
p 01 00000 00000 0082
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 0238
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 0239
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0xA3 - INC DPTR
#
# r0 = DPTR
p 00 00000 00000 023A
p 01 00000 00000 4086
p 01 00000 00000 0001
#
# r0 = r0 + 1
p 00 00000 00000 023B
p 01 00000 00000 2007
p 01 00000 00000 0001
#
# r3 = 0x0082 - Address of SFR DPTR[7:0]
p 00 00000 00000 023C
p 01 00000 00000 4387
p 01 00000 00000 0082
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 023D
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# r0 = Byteswap to get the upper address byte to [7:0]
p 00 00000 00000 023E
p 01 00000 00000 6000
p 01 00000 00000 0000
#
# r3 = 0x0083 - Address of SFR DPTR[15:8]
p 00 00000 00000 023F
p 01 00000 00000 4387
p 01 00000 00000 0083
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 0240
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 0241
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x03 - RR A
#
# r0= rotate right ACC
p 00 00000 00000 0242
p 01 00000 00000 7067
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0243
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 0244
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x13 - RRC A
#
# r2 = ACC AND 0x0001  - Isolate ACC[0] - Store in r2
p 00 00000 00000 0245
p 01 00000 00000 5267
p 01 00000 00000 0001
#
# r0 = rotate right ACC with Carry
p 00 00000 00000 0246
p 01 00000 00000 7067
p 01 00000 00000 0001
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0247
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# r0 = PSW AND FF7F - Zero the Flags Carry bit
p 00 00000 00000 0248
p 01 00000 00000 5057
p 01 00000 00000 FF7F
#
# Dummy = r2 or 0x0000
p 00 00000 00000 0249
p 01 00000 00000 4582
p 01 00000 00000 0000
#
# Jump if last alu zero to PSW Writeback 
p 00 00000 00000 024A
p 01 00000 00000 1002
p 01 00000 00000 01D0
#
# r0 = r0 OR 0080 - Set the Flags Carry bit
p 00 00000 00000 024B
p 01 00000 00000 4007
p 01 00000 00000 0080
#
# Jump unconditional to PSW Writeback
p 00 00000 00000 024C
p 01 00000 00000 1000
p 01 00000 00000 01D0
#
#
# -----------------------------------------------------
#
# 0x23 - RL A
#
# r0 = ACC OR 0x0000
p 00 00000 00000 024D
p 01 00000 00000 4067
p 01 00000 00000 0000
#
# r0 = r0 + r0 - Shift r0 to left
p 00 00000 00000 024E
p 01 00000 00000 2000
p 01 00000 00000 0000
#
# r2 = ACC AND 0x0001  - Isolate ACC[7] - Store in r2
p 00 00000 00000 024F
p 01 00000 00000 5267
p 01 00000 00000 0080
#
# Jump if last alu zero over next instruction
p 00 00000 00000 0250
p 01 00000 00000 1002
p 01 00000 00000 0252
#
# r0 = r0 OR 0x0001 - Set bit[0]
p 00 00000 00000 0251
p 01 00000 00000 4007
p 01 00000 00000 0001
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0252
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 0253
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
#
# 0x33 - RLC A
#
# r1 = ACC OR 0x0000
p 00 00000 00000 0254
p 01 00000 00000 4167
p 01 00000 00000 0000
#
# r0 = r1 + r1 - Shift r1 to left
p 00 00000 00000 0255
p 01 00000 00000 2011
p 01 00000 00000 0000
#
# r2 = PSW AND 0x0080  - Isolate PSW Carry bit 
p 00 00000 00000 0256
p 01 00000 00000 5257
p 01 00000 00000 0080
#
# Jump if last alu zero over next instruction
p 00 00000 00000 0257
p 01 00000 00000 1002
p 01 00000 00000 0259
#
# r0 = r0 OR 0x0001 - Set bit[0]
p 00 00000 00000 0258
p 01 00000 00000 4007
p 01 00000 00000 0001
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0259
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# r0 = PSW AND FF7F - Zero the Flags Carry bit
p 00 00000 00000 025A
p 01 00000 00000 5057
p 01 00000 00000 FF7F
#
# Dummy = r1 AND 0x0080
p 00 00000 00000 025B
p 01 00000 00000 5517
p 01 00000 00000 0080
#
# Jump if last alu zero to PSW Writeback 
p 00 00000 00000 025C
p 01 00000 00000 1002
p 01 00000 00000 01D0
#
# r0 = r0 OR 0080 - Set the Flags Carry bit
p 00 00000 00000 025D
p 01 00000 00000 4007
p 01 00000 00000 0080
#
# Jump unconditional to PSW Writeback
p 00 00000 00000 025E
p 01 00000 00000 1000
p 01 00000 00000 01D0
#
#
# -----------------------------------------------------
#
# 0x93 - MOVC A,@A+DPTR
#
# r1 = IP + 1  - Store the old IP + 1
p 00 00000 00000 025F
p 01 00000 00000 2177
p 01 00000 00000 0001
#
# IP = ACC + DPTR  - Point IP to the calculated Code Byte 
p 00 00000 00000 0260
p 01 00000 00000 2766
p 01 00000 00000 0000
#
# IP = r1   - Restore the old IP + 1
p 00 00000 00000 0261
p 01 00000 00000 4781
p 01 00000 00000 0000
#
# r0 = BIU_RETURN_DATA
p 00 00000 00000 0262
p 01 00000 00000 4047
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0263
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop - Skipping past the IP increment
p 00 00000 00000 0264
p 01 00000 00000 1000
p 01 00000 00000 0102
#
#
# -----------------------------------------------------
#
# 0x83 - MOVC A,@A+PC
#
# r1 = IP + 1  - Store the old IP + 1
p 00 00000 00000 0265
p 01 00000 00000 2177
p 01 00000 00000 0001
#
# IP = ACC + r1  - Point IP to the calculated Code Byte 
p 00 00000 00000 0266
p 01 00000 00000 2761
p 01 00000 00000 0000
#
# Jump unconditional to common code
p 00 00000 00000 0267
p 01 00000 00000 1000
p 01 00000 00000 0261
#
#
# -----------------------------------------------------
#
# JUMP_TAKEN
#
# Call FETCH_IMMEDIATE - Get next instruction byte
p 00 00000 00000 0268
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r0 = BIU_RETURN_DATA - Store the destination address
p 00 00000 00000 0269
p 01 00000 00000 4047
p 01 00000 00000 0000
#
# IP = IP + 1  - Point IP to the next instruction opcode
p 00 00000 00000 026A
p 01 00000 00000 2777
p 01 00000 00000 0001
#
# Dummy = r0 AND 0x0080  - Isolate r0[7], the sign bit
p 00 00000 00000 026B
p 01 00000 00000 5507
p 01 00000 00000 0080
#
# Jump if last alu zero over next instruction
p 00 00000 00000 026C
p 01 00000 00000 1002
p 01 00000 00000 026E
#
# r0 = r0 OR 0xFF00 - Sign extend negative displacement
p 00 00000 00000 026D
p 01 00000 00000 4007
p 01 00000 00000 FF00
#
# IP = IP + r0  - Jump to new displacement address
p 00 00000 00000 026E
p 01 00000 00000 2770
p 01 00000 00000 0000
#
# Jump unconditional to Main Loop - Skipping past the IP increment
p 00 00000 00000 026F
p 01 00000 00000 1000
p 01 00000 00000 0102
#
#
#
# -----------------------------------------------------
#
# JUMP_NOT_TAKEN
#
# IP = IP + 2  - Increment IP past the unused displacement byte
p 00 00000 00000 0270
p 01 00000 00000 2777
p 01 00000 00000 0002
#
# Jump unconditional to Main Loop - Skipping past the IP increment
p 00 00000 00000 0271
p 01 00000 00000 1000
p 01 00000 00000 0102
#
#
# -----------------------------------------------------
#
# 0x60 - JZ Relative
#
# r0 = ACC or 0x0000
p 00 00000 00000 0272
p 01 00000 00000 4067
p 01 00000 00000 0000
#
# Jump Zero to JUMP_TAKEN
p 00 00000 00000 0273
p 01 00000 00000 1002
p 01 00000 00000 0268
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00000 0274
p 01 00000 00000 1000
p 01 00000 00000 0270
#
#
# -----------------------------------------------------
#
# 0x70 - JNZ Relative
#
# r0 = ACC or 0x0000
p 00 00000 00000 0275
p 01 00000 00000 4067
p 01 00000 00000 0000
#
# Jump NonZero to JUMP_TAKEN
p 00 00000 00000 0276
p 01 00000 00000 1001
p 01 00000 00000 0268
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00000 0277
p 01 00000 00000 1000
p 01 00000 00000 0270
#
#
# -----------------------------------------------------
#
# 0x50 - JNC Relative
#
# r0 = PSW AND 0x0080
p 00 00000 00000 0278
p 01 00000 00000 5057
p 01 00000 00000 0080
#
# Jump Zero to JUMP_TAKEN
p 00 00000 00000 0279
p 01 00000 00000 1002
p 01 00000 00000 0268
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00000 027A
p 01 00000 00000 1000
p 01 00000 00000 0270
#
#
# -----------------------------------------------------
#
# 0x40 - JC Relative
#
# r0 = PSW AND 0x0080
p 00 00000 00000 027B
p 01 00000 00000 5057
p 01 00000 00000 0080
#
# Jump NonZero to JUMP_TAKEN
p 00 00000 00000 027C
p 01 00000 00000 1001
p 01 00000 00000 0268
#
# Jump unconditional to JUMP_NOT_TAKEN
p 00 00000 00000 027D
p 01 00000 00000 1000
p 01 00000 00000 0270
#
#
# -----------------------------------------------------
#
# 0x73 - JMP @A+DPTR
#
# IP = ACC + DPTR  - Point IP to the calculated address 
p 00 00000 00000 027E
p 01 00000 00000 2766
p 01 00000 00000 0000
#
# Jump unconditional to Main Loop - Skipping past the IP increment
p 00 00000 00000 027F
p 01 00000 00000 1000
p 01 00000 00000 0102
#
#
# -----------------------------------------------------
#
# 0xB4 - CJNE A, Immediate, Relative
#
# r1 = ACC or 0x0000
p 00 00000 00000 0280
p 01 00000 00000 4167
p 01 00000 00000 0000
#
# Call FETCH_IMMEDIATE - Get next instruction byte
p 00 00000 00000 0281
p 01 00000 00000 1100
p 01 00000 00000 012E
#
# r2 = BIU_RETURN_DATA 
p 00 00000 00000 0282
p 01 00000 00000 4247
p 01 00000 00000 0000
#
#
#  CJNE Main code
#
# r0 = PSW AND FF7F - Zero the Flags Carry bit
p 00 00000 00000 0283
p 01 00000 00000 5057
p 01 00000 00000 FF7F
#
# r2 = r2 XOR 0xFFFF - 1's Compliment
p 00 00000 00000 0284
p 01 00000 00000 3227
p 01 00000 00000 FFFF
#
# r2 = r2 + 1 - Finish the 2's compliment
p 00 00000 00000 0285
p 01 00000 00000 2227
p 01 00000 00000 0001
#
# r1 = r1 + r2 - Subtract the two numbers
p 00 00000 00000 0286
p 01 00000 00000 2112
p 01 00000 00000 0000
#
# Dummy = r1 AND 0x0100  - Isolate r1[8] to see if the resulting subtraction went negative
p 00 00000 00000 0287
p 01 00000 00000 5517
p 01 00000 00000 0100
#
# Jump Zero over next instruction
p 00 00000 00000 0288
p 01 00000 00000 1002
p 01 00000 00000 028A
#
# r0 = PSW OR 0x0080 - Set C Flag
p 00 00000 00000 0289
p 01 00000 00000 4057
p 01 00000 00000 0080
#
# r3 = 0x00D0 - Address of the PSW SFR
p 00 00000 00000 028A
p 01 00000 00000 4387
p 01 00000 00000 00D0
#
# Call WRITEBACK_DIRECT  - Write the PSW back to SFR memory
p 00 00000 00000 028B
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# r1 = 0x0000 OR r1 - Look at r1 again
p 00 00000 00000 028C
p 01 00000 00000 4181
p 01 00000 00000 0000
#
# Jump Zero to JUMP_NOT_TAKEN
p 00 00000 00000 028D
p 01 00000 00000 1002
p 01 00000 00000 0270
#
# Jump unconditional to JUMP_TAKEN
p 00 00000 00000 028E
p 01 00000 00000 1000
p 01 00000 00000 0268
#
#
# -----------------------------------------------------
#
# 0xB6-0xB7 - CJNE @Ri, Immediate, Relative
#
# Call FETCH_Ri_BYTE
p 00 00000 00000 028F
p 01 00000 00000 1100
p 01 00000 00000 0128
#
# r1 = r0
p 00 00000 00000 0290
p 01 00000 00000 4180
p 01 00000 00000 0000
#
# Jump unconditional to common code
p 00 00000 00000 0291
p 01 00000 00000 1000
p 01 00000 00000 0281
#
#
# -----------------------------------------------------
#
# 0xB8-0xBF - CJNE Rx, Immediate, Relative
#
# Call FETCH_Rx_BYTE
p 00 00000 00000 0292
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# r1 = r0
p 00 00000 00000 0293
p 01 00000 00000 4180
p 01 00000 00000 0000
#
# Jump unconditional to common code
p 00 00000 00000 0294
p 01 00000 00000 1000
p 01 00000 00000 0281
#
#
# -----------------------------------------------------
#
# 0xB5 - CJNE A, (Direct), Relative
#
# r1 = ACC or 0x0000
p 00 00000 00000 0295
p 01 00000 00000 4167
p 01 00000 00000 0000
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 0296
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# r2 = r0
p 00 00000 00000 0297
p 01 00000 00000 4280
p 01 00000 00000 0000
#
# Jump unconditional to common code
p 00 00000 00000 0298
p 01 00000 00000 1000
p 01 00000 00000 0283
#



#
# -----------------------------------------------------
#
# 0xD8-0xDF - DJNZ Rx, Relative
#
# Call FETCH_Rx_BYTE
p 00 00000 00000 0299
p 01 00000 00000 1100
p 01 00000 00000 0114
#
# r0 = r0 - 1
p 00 00000 00000 029A
p 01 00000 00000 2007
p 01 00000 00000 FFFF
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 029B
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# r0 = 0x0000 OR r0 - Look at r0 again
p 00 00000 00000 029C
p 01 00000 00000 4080
p 01 00000 00000 0000
#
# Jump Zero to JUMP_NOT_TAKEN
p 00 00000 00000 029D
p 01 00000 00000 1002
p 01 00000 00000 0270
#
# Jump unconditional to JUMP_TAKEN
p 00 00000 00000 029E
p 01 00000 00000 1000
p 01 00000 00000 0268
#
#
# -----------------------------------------------------
#
# 0xD5 - DJNZ (Direct), Relative
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 029F
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# Jump unconditional to common code
p 00 00000 00000 02A0
p 01 00000 00000 1000
p 01 00000 00000 029A
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# PROCEDURE - PUSH
#
# Inputs      r0 = Data to push to the stack
#
#
# -----------------------------------------------------
#
# r2 = r0 - Temporary storage of data to push to stack
p 00 00000 00000 02A1
p 01 00000 00000 4280
p 01 00000 00000 0000
#
# r0 = 1
p 00 00000 00000 02A2
p 01 00000 00000 4087
p 01 00000 00000 0001
#
# r0 = r0 + SP  -- Increment the Stack Pointer - SP
p 00 00000 00000 02A3
p 01 00000 00000 2004
p 01 00000 00000 0000
#
# r3 = 0x0081 - Address of the Stack Pointer
p 00 00000 00000 02A4
p 01 00000 00000 4387
p 01 00000 00000 0081
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 02A5
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# r0 = r2 - Restore data to push to the stack
p 00 00000 00000 02A6
p 01 00000 00000 4082
p 01 00000 00000 0000
#
# r3 = Address that the Stack points to
p 00 00000 00000 02A7
p 01 00000 00000 4384
p 01 00000 00000 0000
#
# Call WRITEBACK_INDIRECT
p 00 00000 00000 02A8
p 01 00000 00000 1100
p 01 00000 00000 0122
#
# Unconditional Jump to return address
p 00 00000 00000 02A9
p 01 00000 00000 1030
p 01 00000 00000 0000
#
#
# -----------------------------------------------------
#
# 0xC0 - PUSH (Direct)
#
# Call FETCH_IMMEDIATE_DIRECT
p 00 00000 00000 02AA
p 01 00000 00000 1100
p 01 00000 00000 0110
#
# Call PUSH
p 00 00000 00000 02AB
p 01 00000 00000 1100
p 01 00000 00000 02A1
#
# Jump unconditional to Main Loop
p 00 00000 00000 02AC
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# PROCEDURE - POP
#
# Output      r0 = Data popped from the stack
#
#
# -----------------------------------------------------
#
# r3 = Address that the Stack points to
p 00 00000 00000 02AD
p 01 00000 00000 4384
p 01 00000 00000 0000
#
# Call FETCH_INDIRECT_BYTE - Pop data from the stack
p 00 00000 00000 02AE
p 01 00000 00000 1100
p 01 00000 00000 010A
#
# r2 = r0 - Temporary storage of data popped from the stack
p 00 00000 00000 02AF
p 01 00000 00000 4280
p 01 00000 00000 0000
#
# r0 = -1 (0xFFFF)
p 00 00000 00000 02B0
p 01 00000 00000 4087
p 01 00000 00000 FFFF
#
# r0 = r0 + SP  -- Decrement the Stack Pointer - SP
p 00 00000 00000 02B1
p 01 00000 00000 2004
p 01 00000 00000 0000
#
# r3 = 0x0081 - Address of the Stack Pointer
p 00 00000 00000 02B2
p 01 00000 00000 4387
p 01 00000 00000 0081
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 02B3
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# r0 = r2 - Restore data popped from the stack
p 00 00000 00000 02B4
p 01 00000 00000 4082
p 01 00000 00000 0000
#
# Unconditional Jump to return address
p 00 00000 00000 02B5
p 01 00000 00000 1030
p 01 00000 00000 0000
#
#
# -----------------------------------------------------
#
# 0xD0 - POP (Direct)
#
# Call POP
p 00 00000 00000 02B6
p 01 00000 00000 1100
p 01 00000 00000 02AD
#
# Jump unconditional to common code
p 00 00000 00000 02B7
p 01 00000 00000 1000
p 01 00000 00000 018E
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x11, 0x31, 0x51, 0x71   -  ACALL P0 - P7
# 0x91, 0xB1, 0xD1, 0xF1
#
# r0 = PC + 2
p 00 00000 00000 02B8
p 01 00000 00000 2077
p 01 00000 00000 0002
#
# Call PUSH  - Push PC[7:0] to the stack
p 00 00000 00000 02B9
p 01 00000 00000 1100
p 01 00000 00000 02A1
#
# Byte-swap r0
p 00 00000 00000 02BA
p 01 00000 00000 6000
p 01 00000 00000 0000
#
# Call PUSH  - Push PC[15:8] to the stack
p 00 00000 00000 02BB
p 01 00000 00000 1100
p 01 00000 00000 02A1
#
#
# AJMP Main
# 0x01, 0x21, 0x41, 0x61   -  AJMP P0 - P7
# 0x81, 0xA1, 0xC1, 0xE1
#
# r2 = SHR  BIU_RETURN_DATA 
p 00 00000 00000 02BC
p 01 00000 00000 7240
p 01 00000 00000 0000
#
# PC = PC + 1
p 00 00000 00000 02BD
p 01 00000 00000 2777
p 01 00000 00000 0001
#
# r2 = SHR  r2 
p 00 00000 00000 02BE
p 01 00000 00000 7220
p 01 00000 00000 0000
#
# r2 = SHR  r2 
p 00 00000 00000 02BF
p 01 00000 00000 7220
p 01 00000 00000 0000
#
# r2 = SHR  r2 
p 00 00000 00000 02C0
p 01 00000 00000 7220
p 01 00000 00000 0000
#
# r2 = SHR  r2 
p 00 00000 00000 02C1
p 01 00000 00000 7220
p 01 00000 00000 0000
#
# r0 = Byte-swap r2
p 00 00000 00000 02C2
p 01 00000 00000 6022
p 01 00000 00000 0000
#
# r0 = r0 AND 0x07FF - Clear the upper bits that were shifted in
p 00 00000 00000 02C3
p 01 00000 00000 5007
p 01 00000 00000 07FF
#
# PC = BIU_RETURN_DATA OR r0
p 00 00000 00000 02C4
p 01 00000 00000 4740
p 01 00000 00000 0000
#
# Jump unconditional to Main Loop - Skipping past the IP increment
p 00 00000 00000 02C5
p 01 00000 00000 1000
p 01 00000 00000 0102
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x12 - LCALL Addr16
#
# r0 = PC + 3
p 00 00000 00000 02C6
p 01 00000 00000 2077
p 01 00000 00000 0003
#
# Call PUSH  - Push PC[7:0] to the stack
p 00 00000 00000 02C7
p 01 00000 00000 1100
p 01 00000 00000 02A1
#
# Byte-swap r0
p 00 00000 00000 02C8
p 01 00000 00000 6000
p 01 00000 00000 0000
#
# Call PUSH  - Push PC[15:8] to the stack
p 00 00000 00000 02C9
p 01 00000 00000 1100
p 01 00000 00000 02A1
#
#
# 0x02 - LJMP Addr16
#
# PC = PC + 1
p 00 00000 00000 02CA
p 01 00000 00000 2777
p 01 00000 00000 0001
#
# PC = PC + 1
p 00 00000 00000 02CB
p 01 00000 00000 2777
p 01 00000 00000 0001
#
# r0 = BIU_RETURN_DATA  - Address[15:8]
p 00 00000 00000 02CC
p 01 00000 00000 4047
p 01 00000 00000 0000
#
# Byte-swap r0
p 00 00000 00000 02CD
p 01 00000 00000 6000
p 01 00000 00000 0000
#
# PC = BIU_RETURN_DATA OR r0
p 00 00000 00000 02CE
p 01 00000 00000 4740
p 01 00000 00000 0000
#
# Jump unconditional to Main Loop - Skipping past the IP increment
p 00 00000 00000 02CF
p 01 00000 00000 1000
p 01 00000 00000 0102
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0xC4 - SWAP A
#
# r0 = SHR  ACC
p 00 00000 00000 02D0
p 01 00000 00000 7067
p 01 00000 00000 0000
#
# r0 = SHR  r0
p 00 00000 00000 02D1
p 01 00000 00000 7007
p 01 00000 00000 0000
#
# r0 = SHR  r0
p 00 00000 00000 02D2
p 01 00000 00000 7007
p 01 00000 00000 0000
#
# r0 = SHR  r0
p 00 00000 00000 02D3
p 01 00000 00000 7007
p 01 00000 00000 0000
#
# Jump unconditional to common code to writeback the accumulator
p 00 00000 00000 02D4
p 01 00000 00000 1000
p 01 00000 00000 0252
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# PROCEDURE - BIT_CALCULATE
#
# Outputs     r3 = Byte Address
#             r2 = 
#             r1 = Bit Mask
#             r0 = Byte Data
#   
# -----------------------------------------------------
#
# PC = PC + 1   - Increment to the next opcode byte
p 00 00000 00000 02D5
p 01 00000 00000 2777
p 01 00000 00000 0001
#
# NOP - To give time for Program ROM to deliver the next opcode
p 00 00000 00000 02D6
p 01 00000 00000 0000
p 01 00000 00000 0000
#
# Jump-4 to opcode decode at base address 0x2E--
p 00 00000 00000 02D7
p 01 00000 00000 1040
p 01 00000 00000 002E
#
# Dummy = BIU_RETURN_DATA AND 0x0080 - Isolate bit[7] of the bit address
p 00 00000 00000 02D8
p 01 00000 00000 5547
p 01 00000 00000 0080
#
# Jump if zero to SUB-0x80 processing
p 00 00000 00000 02D9
p 01 00000 00000 1002
p 01 00000 00000 02F0
#
# Bit Address is greater than 0x80
#
# r3 = BIU_RETURN_DATA AND 0x00F8 - Clear the bit address to create the byte address
p 00 00000 00000 02DA
p 01 00000 00000 5347
p 01 00000 00000 00F8
#
# Call FETCH_DIRECT_BYTE - Fetch the byte pointed to by the bit address
p 00 00000 00000 02DB
p 01 00000 00000 1100
p 01 00000 00000 0117
#
# Unconditional Jump to return address
p 00 00000 00000 02DC
p 01 00000 00000 1030
p 01 00000 00000 0000
#
#
# 0xB2 - CPLB Bit
#
# Call BIT_CALCULATE
p 00 00000 00000 02DD
p 01 00000 00000 1100
p 01 00000 00000 02D5
#
# r0 = r0 XOR r1  - XOR the original in r0 with the bitmask in r1
p 00 00000 00000 02DE
p 01 00000 00000 3001
p 01 00000 00000 0000
#
# Jump unconditional to common code to Writeback Direct
p 00 00000 00000 02DF
p 01 00000 00000 1000
p 01 00000 00000 0240
#
#
# Bit Mask Table
# --------------
#
# r1 = 00000001
p 00 00000 00000 02E0
p 01 00000 00000 4187
p 01 00000 00000 0001
#
# Jump unconditional back to Bit Calculate procedure
p 00 00000 00000 02E1
p 01 00000 00000 1000
p 01 00000 00000 02D8
#
# r1 = 00000010
p 00 00000 00000 02E2
p 01 00000 00000 4187
p 01 00000 00000 0002
#
# Jump unconditional back to Bit Calculate procedure
p 00 00000 00000 02E3
p 01 00000 00000 1000
p 01 00000 00000 02D8
#
# r1 = 00000100
p 00 00000 00000 02E4
p 01 00000 00000 4187
p 01 00000 00000 0004
#
# Jump unconditional back to Bit Calculate procedure
p 00 00000 00000 02E5
p 01 00000 00000 1000
p 01 00000 00000 02D8
#
# r1 = 00001000
p 00 00000 00000 02E6
p 01 00000 00000 4187
p 01 00000 00000 0008
#
# Jump unconditional back to Bit Calculate procedure
p 00 00000 00000 02E7
p 01 00000 00000 1000
p 01 00000 00000 02D8
#
# r1 = 00010000
p 00 00000 00000 02E8
p 01 00000 00000 4187
p 01 00000 00000 0010
#
# Jump unconditional back to Bit Calculate procedure
p 00 00000 00000 02E9
p 01 00000 00000 1000
p 01 00000 00000 02D8
#
# r1 = 00100000
p 00 00000 00000 02EA
p 01 00000 00000 4187
p 01 00000 00000 0020
#
# Jump unconditional back to Bit Calculate procedure
p 00 00000 00000 02EB
p 01 00000 00000 1000
p 01 00000 00000 02D8
#
# r1 = 01000000
p 00 00000 00000 02EC
p 01 00000 00000 4187
p 01 00000 00000 0040
#
# Jump unconditional back to Bit Calculate procedure
p 00 00000 00000 02ED
p 01 00000 00000 1000
p 01 00000 00000 02D8
#
# r1 = 10000000
p 00 00000 00000 02EE
p 01 00000 00000 4187
p 01 00000 00000 0080
#
# Jump unconditional back to Bit Calculate procedure
p 00 00000 00000 02EF
p 01 00000 00000 1000
p 01 00000 00000 02D8
#
#
# Bit Address is less than 0x80
#
# r3 = SHR BIU_RETURN_DATA
p 00 00000 00000 02F0
p 01 00000 00000 7347
p 01 00000 00000 0000
#
# r3 = SHR r3
p 00 00000 00000 02F1
p 01 00000 00000 7337
p 01 00000 00000 0000
#
# r3 = SHR r3
p 00 00000 00000 02F2
p 01 00000 00000 7337
p 01 00000 00000 0000
#
# r3 = r3 AND 0x0007 - Clear the rotated-in bits
p 00 00000 00000 02F3
p 01 00000 00000 5337
p 01 00000 00000 0007
#
# r3 = r3 OR 0x0020 - Prepend 0x2- to create the byte address
p 00 00000 00000 02F4
p 01 00000 00000 4337
p 01 00000 00000 0020
#
# Jump unconditional to common code
p 00 00000 00000 02F5
p 01 00000 00000 1000
p 01 00000 00000 02DB
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0xD2 - SETB Bit
#
# Call BIT_CALCULATE
p 00 00000 00000 02F6
p 01 00000 00000 1100
p 01 00000 00000 02D5
#
# r0 = r0 OR r1  - OR the original in r0 with the bitmask in r1
p 00 00000 00000 02F7
p 01 00000 00000 4001
p 01 00000 00000 0000
#
# Jump unconditional to common code to Writeback Direct
p 00 00000 00000 02F8
p 01 00000 00000 1000
p 01 00000 00000 0240
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0xC2 - CLRB Bit
#
# Call BIT_CALCULATE
p 00 00000 00000 02F9
p 01 00000 00000 1100
p 01 00000 00000 02D5
#
# r2 = r1 XOR 0xFFFF - Compliment the Bit Mask
p 00 00000 00000 02FA
p 01 00000 00000 3217
p 01 00000 00000 FFFF
#
# r0 = r0 AND r2  - OR the original in r0 with the complimented bitmask in r2
p 00 00000 00000 02FB
p 01 00000 00000 5002
p 01 00000 00000 0000
#
# Jump unconditional to common code to Writeback Direct
p 00 00000 00000 02FC
p 01 00000 00000 1000
p 01 00000 00000 0240
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x20 - JB Bit, Relative
#
# Call BIT_CALCULATE
p 00 00000 00000 02FD
p 01 00000 00000 1100
p 01 00000 00000 02D5
#
# r0 = r0 AND r1  - AND the original in r0 with the bitmask in r2
p 00 00000 00000 02FE
p 01 00000 00000 5001
p 01 00000 00000 0000
#
# Jump Zero to JUMP_NOT_TAKEN
p 00 00000 00000 02FF
p 01 00000 00000 1002
p 01 00000 00000 0270
#
# Jump unconditional to JUMP_TAKEN
p 00 00000 00000 0300
p 01 00000 00000 1000
p 01 00000 00000 0268
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x30 - JNB Bit, Relative
#
# Call BIT_CALCULATE
p 00 00000 00000 0301
p 01 00000 00000 1100
p 01 00000 00000 02D5
#
# r0 = r0 AND r1  - AND the original in r0 with the bitmask in r2
p 00 00000 00000 0302
p 01 00000 00000 5001
p 01 00000 00000 0000
#
# Jump nonzero to JUMP_NOT_TAKEN
p 00 00000 00000 0303
p 01 00000 00000 1001
p 01 00000 00000 0270
#
# Jump unconditional to JUMP_TAKEN
p 00 00000 00000 0304
p 01 00000 00000 1000
p 01 00000 00000 0268
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x10 - JBC Bit, Relative
#
# Call BIT_CALCULATE
p 00 00000 00000 0305
p 01 00000 00000 1100
p 01 00000 00000 02D5
#
# r2 = r0 AND r1  - AND the original in r0 with the bitmask in r1 - Temp Store in r2
p 00 00000 00000 0306
p 01 00000 00000 5201
p 01 00000 00000 0000
#
# r1 = r1 XOR 0xFFFF - Compliment the Bit Mask
p 00 00000 00000 0307
p 01 00000 00000 3117
p 01 00000 00000 FFFF
#
# r0 = r0 AND r1  - OR the original in r0 with the complimented bitmask in r1
p 00 00000 00000 0308
p 01 00000 00000 5001
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 0309
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# r2 = 0x0000 OR r2  - Re-establish r2 results
p 00 00000 00000 030A
p 01 00000 00000 4282
p 01 00000 00000 0000
#
# Jump Zero to JUMP_NOT_TAKEN
p 00 00000 00000 030B
p 01 00000 00000 1002
p 01 00000 00000 0270
#
# Jump unconditional to JUMP_TAKEN
p 00 00000 00000 030C
p 01 00000 00000 1000
p 01 00000 00000 0268
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x72 - ORL C, Bit
#
# Call BIT_CALCULATE
p 00 00000 00000 030D
p 01 00000 00000 1100
p 01 00000 00000 02D5
#
# r0 = r0 AND r1  - AND the data in r0 with the bitmask in r1
p 00 00000 00000 030E
p 01 00000 00000 5001
p 01 00000 00000 0000
#
# Jump zero to Main Loop
p 00 00000 00000 030F
p 01 00000 00000 1002
p 01 00000 00000 0101
#
# r0 = PSW OR 0080 - Set the Flags Carry bit
p 00 00000 00000 0310
p 01 00000 00000 4057
p 01 00000 00000 0080
#
# Jump unconditional to PSW Writeback
p 00 00000 00000 0311
p 01 00000 00000 1000
p 01 00000 00000 01D0
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0xA0 - ORL C, ~Bit
#
# Call BIT_CALCULATE
p 00 00000 00000 0312
p 01 00000 00000 1100
p 01 00000 00000 02D5
#
# r0 = r0 AND r1  - AND the data in r0 with the bitmask in r1
p 00 00000 00000 0313
p 01 00000 00000 5001
p 01 00000 00000 0000
#
# Jump nonzero to Main Loop
p 00 00000 00000 0314
p 01 00000 00000 1001
p 01 00000 00000 0101
#
# r0 = PSW OR 0080 - Set the Flags Carry bit
p 00 00000 00000 0315
p 01 00000 00000 4057
p 01 00000 00000 0080
#
# Jump unconditional to PSW Writeback
p 00 00000 00000 0316
p 01 00000 00000 1000
p 01 00000 00000 01D0
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x82 - ANL C, Bit
#
# Call BIT_CALCULATE
p 00 00000 00000 0317
p 01 00000 00000 1100
p 01 00000 00000 02D5
#
# r0 = r0 AND r1  - AND the data in r0 with the bitmask in r1
p 00 00000 00000 0318
p 01 00000 00000 5001
p 01 00000 00000 0000
#
# Jump nonzero to Main Loop
p 00 00000 00000 0319
p 01 00000 00000 1001
p 01 00000 00000 0101
#
# r0 = PSW AND FF7F - Clear the Flags Carry bit
p 00 00000 00000 031A
p 01 00000 00000 5057
p 01 00000 00000 FF7F
#
# Jump unconditional to PSW Writeback
p 00 00000 00000 031B
p 01 00000 00000 1000
p 01 00000 00000 01D0
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0xB0 - ANL C, ~Bit
#
# Call BIT_CALCULATE
p 00 00000 00000 031C
p 01 00000 00000 1100
p 01 00000 00000 02D5
#
# r0 = r0 AND r1  - AND the data in r0 with the bitmask in r1
p 00 00000 00000 031D
p 01 00000 00000 5001
p 01 00000 00000 0000
#
# Jump zero to Main Loop
p 00 00000 00000 031E
p 01 00000 00000 1002
p 01 00000 00000 0101
#
# r0 = PSW AND FF7F - Clear the Flags Carry bit
p 00 00000 00000 031F
p 01 00000 00000 5057
p 01 00000 00000 FF7F
#
# Jump unconditional to PSW Writeback
p 00 00000 00000 0320
p 01 00000 00000 1000
p 01 00000 00000 01D0
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0xA2 - MOV C, Bit
#
# Call BIT_CALCULATE
p 00 00000 00000 0321
p 01 00000 00000 1100
p 01 00000 00000 02D5
#
# r0 = r0 AND r1  - AND the data in r0 with the bitmask in r1
p 00 00000 00000 0322
p 01 00000 00000 5001
p 01 00000 00000 0000
#
# Jump nonzero to common code to Set the Carry Bit
p 00 00000 00000 0323
p 01 00000 00000 1001
p 01 00000 00000 0315
#
# Jump unconditional to common code to Clear the Carry Bit
p 00 00000 00000 0324
p 01 00000 00000 1000
p 01 00000 00000 031F
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x92 - MOV Bit, C
#
# Dummy = PSW AND 0080 - Isolate the PSW Carry bit
p 00 00000 00000 0325
p 01 00000 00000 5557
p 01 00000 00000 0080
#
# Jump nonzero to SETB common code
p 00 00000 00000 0326
p 01 00000 00000 1001
p 01 00000 00000 02F6
#
# Jump unconditional to CLRB common code
p 00 00000 00000 0327
p 01 00000 00000 1000
p 01 00000 00000 02F9
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0xD4 - DA 
#
# r2 = ACC  
p 00 00000 00000 0328
p 01 00000 00000 4267
p 01 00000 00000 0000
#
# Dummy = PSW AND 0040 - Isolate the PSW Aux bit
p 00 00000 00000 0329
p 01 00000 00000 5557
p 01 00000 00000 0040
#
# Jump nonzero to DA_YES1:
p 00 00000 00000 032A
p 01 00000 00000 1001
p 01 00000 00000 032F
#
# r1 = r2 AND 0x000F - Isolate the low nibble
p 00 00000 00000 032B
p 01 00000 00000 5127
p 01 00000 00000 000F
#
# r1 = r1 + 6
p 00 00000 00000 032C
p 01 00000 00000 2117
p 01 00000 00000 0006
#
# Dummy = r1 AND FFF0 - Results will overflow into [7:4] if ACC > 9
p 00 00000 00000 032D
p 01 00000 00000 5517
p 01 00000 00000 FFF0
#
# Jump zero to DA_CHECK2:
p 00 00000 00000 032E
p 01 00000 00000 1002
p 01 00000 00000 0335
#
# DA_YES1:
#
# r2 = r2 + 6
p 00 00000 00000 032F
p 01 00000 00000 2227
p 01 00000 00000 0006
#
# Dummy = alu_flags AND 8000 - Isolate the alu_carry bit
p 00 00000 00000 0330
p 01 00000 00000 5557
p 01 00000 00000 8000
#
# Jump zero to DA_CHECK2:
p 00 00000 00000 0331
p 01 00000 00000 1002
p 01 00000 00000 0335
#
# r0 = PSW SFR OR 0x0080 - Set the PSW Carry Flag
p 00 00000 00000 0332
p 01 00000 00000 4057
p 01 00000 00000 0080
#
# r3 = 0x00D0 - Address of the PSW SFR
p 00 00000 00000 0333
p 01 00000 00000 4387
p 01 00000 00000 00D0
#
# Call WRITEBACK_DIRECT  - Write the PSW back to SFR memory
p 00 00000 00000 0334
p 01 00000 00000 1100
p 01 00000 00000 011C
#

# DA_CHECK2:
#

# Dummy = PSW AND 0080 - Isolate the PSW Carry bit
p 00 00000 00000 0335
p 01 00000 00000 5557
p 01 00000 00000 0080
#
# Jump nonzero to DA_YES2:
p 00 00000 00000 0336
p 01 00000 00000 1001
p 01 00000 00000 033B
#
# r1 = r2 AND 0x00F0 - Isolate the upper nibble
p 00 00000 00000 0337
p 01 00000 00000 5127
p 01 00000 00000 00F0
#
# r1 = r1 + 60
p 00 00000 00000 0338
p 01 00000 00000 2117
p 01 00000 00000 0060
#
# Dummy = r1 AND FF00 - Results will overflow into [11:8] if ACC > 90
p 00 00000 00000 0339
p 01 00000 00000 5517
p 01 00000 00000 FF00
#
# Jump zero to DA_DONE:
p 00 00000 00000 033A
p 01 00000 00000 1002
p 01 00000 00000 0341
#
# DA_YES2:
#
# r2 = r2 + 60
p 00 00000 00000 033B
p 01 00000 00000 2227
p 01 00000 00000 0060
#
# Dummy = alu_flags AND 8000 - Isolate the alu_carry bit
p 00 00000 00000 033C
p 01 00000 00000 5557
p 01 00000 00000 8000
#
# Jump zero to DA_DONE:
p 00 00000 00000 033D
p 01 00000 00000 1002
p 01 00000 00000 0341
#
# r0 = PSW SFR OR 0x0080 - Set the PSW Carry Flag
p 00 00000 00000 033E
p 01 00000 00000 4057
p 01 00000 00000 0080
#
# r3 = 0x00D0 - Address of the PSW SFR
p 00 00000 00000 033F
p 01 00000 00000 4387
p 01 00000 00000 00D0
#
# Call WRITEBACK_DIRECT  - Write the PSW back to SFR memory
p 00 00000 00000 0340
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# DA_DONE:
#
# r0 = r2    - Writeback the ACC
p 00 00000 00000 0341
p 01 00000 00000 4082
p 01 00000 00000 0000
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0342
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# Jump unconditional to Main Loop
p 00 00000 00000 0343
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0xA4 - MUL AB
#
# r3 = 0x00F0 - Address of the SFR register B
p 00 00000 00000 0350
p 01 00000 00000 4387
p 01 00000 00000 00F0
#
# Call FETCH_DIRECT_BYTE
p 00 00000 00000 0351
p 01 00000 00000 1100
p 01 00000 00000 0117
#
# r0 = Byte Swap B to put multiplier in upper byte
p 00 00000 00000 0352
p 01 00000 00000 6000
p 01 00000 00000 0000
#
# r1 = 0x0008  - Bit Counter
p 00 00000 00000 0353
p 01 00000 00000 4187
p 01 00000 00000 0008
#
# r2 = ACC
p 00 00000 00000 0354
p 01 00000 00000 4267
p 01 00000 00000 0000
#
#
# LOOP_TOP:
#
# Dummy = r0 + 0 - Clears the CARRY16 flag
p 00 00000 00000 0355
p 01 00000 00000 2507
p 01 00000 00000 0000
#
# Isolate r2[0] into Dummy
p 00 00000 00000 0356
p 01 00000 00000 5527
p 01 00000 00000 0001
#
# Jump if zero directly to SHIFT:
p 00 00000 00000 0357
p 01 00000 00000 1002
p 01 00000 00000 0359
#
# r2 = r2 + r0  - Actually r2[15:8] = r2[15:8] + r0[15:8] - CARRY16 flag is established here
p 00 00000 00000 0358
p 01 00000 00000 2202
p 01 00000 00000 0000
#
# SHIFT: r2 to the right using shift-16 which shifts-in CARRY_16 into bit[15]
p 00 00000 00000 0359
p 01 00000 00000 7227
p 01 00000 00000 0002
#
# r1=r1-1  - Decrement the bit counter
p 00 00000 00000 035A
p 01 00000 00000 2117
p 01 00000 00000 FFFF
#
# Jump if last alu non zero to LOOP_TOP:
p 00 00000 00000 035B
p 01 00000 00000 1001
p 01 00000 00000 0355
#
#
# DONE
#
# r0 = PSW AND 0xFF7A - Clear the Carry and Overflow Flag bits
p 00 00000 00000 035C
p 01 00000 00000 5057
p 01 00000 00000 007A
#
# Isolate r2[15:8] into Dummy to see if results in B
p 00 00000 00000 035D
p 01 00000 00000 5527
p 01 00000 00000 FF00
#
 Jump if zero over next instruction
p 00 00000 00000 035E
p 01 00000 00000 1002
p 01 00000 00000 0360
#
# r0 = r0 OR 0x0004 - Set the Overflow Flag
p 00 00000 00000 035F
p 01 00000 00000 4007
p 01 00000 00000 0004
#
# r3 = 0x00D0 - Address of the PSW SFR
p 00 00000 00000 0360
p 01 00000 00000 4387
p 01 00000 00000 00D0
#
# Call WRITEBACK_DIRECT  - Write the PSW back to SFR memory
p 00 00000 00000 0361
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# r0 = r2 AND 0x00FF - Isolate ACC for writeback
p 00 00000 00000 0362
p 01 00000 00000 5027
p 01 00000 00000 00FF
#
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0363
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# r0 = Byte-Swap r2 - Move B into lower byte of r0
p 00 00000 00000 0364
p 01 00000 00000 6027
p 01 00000 00000 0000
#
# r0 = r0 AND 0x00FF - Isolate B for writeback
p 00 00000 00000 0365
p 01 00000 00000 5007
p 01 00000 00000 00FF
#
# r3 = 0x00F0 - Address of the B SFR
p 00 00000 00000 0366
p 01 00000 00000 4387
p 01 00000 00000 00F0
#
# Call WRITEBACK_DIRECT  - Write the register B back to SFR memory
p 00 00000 00000 0367
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# Jump unconditional to Main Loop
p 00 00000 00000 0368
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x84 - DIV AB
#
#
# r0 - { 0 ,  Numerator }  ---> Result: { Remainder , Quotient }
# r1 - { Demoninator, 0 }
# r2 - { ~Demoninator, 0 }
# r3 - Bit counter
#
# Output:  ACC = Quotient
#            B = Remainder
#
# -----------------------------------------------------
#

# r3 = 0x00F0 - Address of the SFR register B
p 00 00000 00000 036F
p 01 00000 00000 4387
p 01 00000 00000 00F0
#
# Call FETCH_DIRECT_BYTE
p 00 00000 00000 0370
p 01 00000 00000 1100
p 01 00000 00000 0117
#
# r0 = r0 
p 00 00000 00000 0371
p 01 00000 00000 4080
p 01 00000 00000 0000
#
# Jump if nonzero to INITIALIZE:  - Test for division by zero
p 00 00000 00000 0372
p 01 00000 00000 1001
p 01 00000 00000 0376
#
# r0 = PSW AND 0xFF7A - Clear the Carry and Overflow Flag bits
p 00 00000 00000 0373
p 01 00000 00000 5057
p 01 00000 00000 007A
#
# r0 = r0 OR 0x0004 - Set the Overflow Flag
p 00 00000 00000 0374
p 01 00000 00000 4007
p 01 00000 00000 0004
#
# Jump unconditional to common code to writeback the PSW and jump to Main Loop
p 00 00000 00000 0375
p 01 00000 00000 1000
p 01 00000 00000 01D0
#
# INITIALIZE:
# r1 = Byteswap r0 = ( B , 0x00 }
p 00 00000 00000 0376
p 01 00000 00000 6100
p 01 00000 00000 0000
#
# r2 = r1 XOR 0xFFFF - 1's Compliment Byte-swapped B
p 00 00000 00000 0377
p 01 00000 00000 3217
p 01 00000 00000 FFFF
#
# r2 = r2 + 1 - Finish the 2's compliment of Byte-swapped B
p 00 00000 00000 0378
p 01 00000 00000 2227
p 01 00000 00000 0001
#
# r2 = r2 AND 0xFF00 - Clear lower byte of ~B
p 00 00000 00000 0379
p 01 00000 00000 5227
p 01 00000 00000 FF00
#
# r0 = ACC
p 00 00000 00000 037A
p 01 00000 00000 4067
p 01 00000 00000 0000
#
# r3 = 0x0008 - Load the Bit counter
p 00 00000 00000 037B
p 01 00000 00000 4387
p 01 00000 00000 0008
#
#
# START: 
# r0 = r0 + r0  - SHL the Quotient
p 00 00000 00000 037C
p 01 00000 00000 2000
p 01 00000 00000 0000
#
# Subtraction Test
# r0 = r0 - r2
p 00 00000 00000 037D
p 01 00000 00000 2002
p 01 00000 00000 0000
#
# Dummy = Flags AND 0x2000 - Isolate the CARY16 Flag
p 00 00000 00000 037E
p 01 00000 00000 5557
p 01 00000 00000 2000
#
# Jump if zero to RESTORE:
p 00 00000 00000 037F
p 01 00000 00000 1002
p 01 00000 00000 0382
#
# r0= r0 OR 0x0001 - Set r0[0] to 1
p 00 00000 00000 0380
p 01 00000 00000 4007
p 01 00000 00000 0001
#
# Jump unconditional to BIT_COUNT_TEST  
p 00 00000 00000 0381
p 01 00000 00000 1000
p 01 00000 00000 0383
#
#
# RESTORE:
# r0 = r0 - r1   - Restore
p 00 00000 00000 0382
p 01 00000 00000 2001
p 01 00000 00000 0000
#
# BIT_COUNT_TEST:
# r3 = r3 - 1 - Decrement the Bit Counter
p 00 00000 00000 0383
p 01 00000 00000 2337
p 01 00000 00000 FFFF
#
# Jump if nonzero to START:
p 00 00000 00000 0384
p 01 00000 00000 1001
p 01 00000 00000 037C
#
#
DONE:
# Call WRITEBACK_DIRECT_ACC
p 00 00000 00000 0385
p 01 00000 00000 1100
p 01 00000 00000 011B
#
# r0 = Byteswap r0 -- Move remainder into lower byte for write back of SFR B
p 00 00000 00000 0386
p 01 00000 00000 6000
p 01 00000 00000 0000
#
# r3 = 0x00F0 - Address of the SFR register B
p 00 00000 00000 0387
p 01 00000 00000 4387
p 01 00000 00000 00F0
#
# Call WRITEBACK_DIRECT
p 00 00000 00000 0388
p 01 00000 00000 1100
p 01 00000 00000 011C
#
# r0 = PSW AND 0xFF7A - Clear the Carry and Overflow Flag bits
p 00 00000 00000 0389
p 01 00000 00000 5057
p 01 00000 00000 007A
#
# Jump unconditional to common code to writeback the PSW and jump to Main Loop
p 00 00000 00000 038A
p 01 00000 00000 1000
p 01 00000 00000 01D0
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x32 - RETI
#
# Strobe BIU to re-enable global interrupts
p 00 00000 00000 0390
p 01 00000 00000 4687
p 01 00000 00000 0004
#
# Debounce BIU Strobe
p 00 00000 00000 0391
p 01 00000 00000 5687
p 01 00000 00000 0000
#
# Call POP - pop IP[15:8] from the stack into r0
p 00 00000 00000 0392
p 01 00000 00000 1100
p 01 00000 00000 02AD
#
# IP = Byte Swap r0 into IP[15:8]
p 00 00000 00000 0393
p 01 00000 00000 6700
p 01 00000 00000 0000
#
# Call POP - pop IP[7:0] from the stack into r0
p 00 00000 00000 0394
p 01 00000 00000 1100
p 01 00000 00000 02AD
#
# IP = IP OR r0
p 00 00000 00000 0395
p 01 00000 00000 4770
p 01 00000 00000 0000
#
# Jump unconditional to Main Loop past IP incrementing and interrupt polling
p 00 00000 00000 0396
p 01 00000 00000 1000
p 01 00000 00000 0104
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# 0x22 - RET
#
# Call POP - pop IP[15:8] from the stack into r0
p 00 00000 00000 0397
p 01 00000 00000 1100
p 01 00000 00000 02AD
#
# IP = Byte Swap r0 into IP[15:8]
p 00 00000 00000 0398
p 01 00000 00000 6700
p 01 00000 00000 0000
#
# Call POP - pop IP[7:0] from the stack into r0
p 00 00000 00000 0399
p 01 00000 00000 1100
p 01 00000 00000 02AD
#
# IP = IP OR r0
p 00 00000 00000 039A
p 01 00000 00000 4770
p 01 00000 00000 0000
#
# Jump unconditional to Main Loop past IP incrementing
p 00 00000 00000 039B
p 01 00000 00000 1000
p 01 00000 00000 0102
#
#
# -----------------------------------------------------
# -----------------------------------------------------
#
# Interrupt Processing microcode
#
#
# Strobe BIU to disable global interrupts
p 00 00000 00000 03A0
p 01 00000 00000 4687
p 01 00000 00000 0003
#
# Debounce BIU Strobe
p 00 00000 00000 03A1
p 01 00000 00000 5687
p 01 00000 00000 0000
#
# r0 = PC
p 00 00000 00000 03A2
p 01 00000 00000 4077
p 01 00000 00000 0000
#
# Call PUSH  - Push PC[7:0] to the stack
p 00 00000 00000 03A3
p 01 00000 00000 1100
p 01 00000 00000 02A1
#
# Byte-swap r0
p 00 00000 00000 03A4
p 01 00000 00000 6000
p 01 00000 00000 0000
#
# Call PUSH  - Push PC[15:8] to the stack
p 00 00000 00000 03A5
p 01 00000 00000 1100
p 01 00000 00000 02A1
#
#
# Fetch the interrupt source from the BIU - SFR register biu_sfr_is_int
#
# r3 = 0x00F0 - Address of the SFR register biu_sfr_is_int
p 00 00000 00000 03A6
p 01 00000 00000 4387
p 01 00000 00000 00A9
#
# Call FETCH_DIRECT_BYTE
p 00 00000 00000 03A7
p 01 00000 00000 1100
p 01 00000 00000 0117
#
# Fetch the 16-bit interupt vector from Program Memory
#
# IP = r0 + r0  - Shift interrupt source to the right one bit
p 00 00000 00000 03A8
p 01 00000 00000 2700
p 01 00000 00000 0000
#
# IP = IP + 1
p 00 00000 00000 03A9
p 01 00000 00000 2777
p 01 00000 00000 0001
#
# r0 = Byte swap BIU_RETURN_DATA - This is the new IP[15:8] of the interrupt service routine
p 00 00000 00000 03AA
p 01 00000 00000 6047
p 01 00000 00000 0000
#
# IP = BIU_RETURN_DATA OR r0
p 00 00000 00000 03AB
p 01 00000 00000 4740
p 01 00000 00000 0000
#
# Jump unconditional to Main Loop past IP incrementing and interrupt polling
p 00 00000 00000 03AC
p 01 00000 00000 1000
p 01 00000 00000 0104
#


# -----------------------------------------------------
# -----------------------------------------------------
# -----------------------------------------------------
# -----------------------------------------------------
#
#
# Opcode Jump Table at 0x000 - 0x0FF - First 256 locations of ROM
# -----------------------------------------------------
#
#
p 00 00000 00000 0000
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
p 00 00000 00000 0001
p 01 00000 00000 1000
p 01 00000 00000 02BC
#
#
p 00 00000 00000 0002
p 01 00000 00000 1000
p 01 00000 00000 02CA
#
#
p 00 00000 00000 0003
p 01 00000 00000 1000
p 01 00000 00000 0242
#
#
p 00 00000 00000 0004
p 01 00000 00000 1000
p 01 00000 00000 0175
#
#
p 00 00000 00000 0005
p 01 00000 00000 1000
p 01 00000 00000 0169
#
#
p 00 00000 00000 0006
p 01 00000 00000 1000
p 01 00000 00000 016D
#
#
p 00 00000 00000 0007
p 01 00000 00000 1000
p 01 00000 00000 016D
#
#
p 00 00000 00000 0008
p 01 00000 00000 1000
p 01 00000 00000 0171
#
#
p 00 00000 00000 0009
p 01 00000 00000 1000
p 01 00000 00000 0171
#
#
p 00 00000 00000 000A
p 01 00000 00000 1000
p 01 00000 00000 0171
#
#
p 00 00000 00000 000B
p 01 00000 00000 1000
p 01 00000 00000 0171
#
#
p 00 00000 00000 000C
p 01 00000 00000 1000
p 01 00000 00000 0171
#
#
p 00 00000 00000 000D
p 01 00000 00000 1000
p 01 00000 00000 0171
#
#
p 00 00000 00000 000E
p 01 00000 00000 1000
p 01 00000 00000 0171
#
#
p 00 00000 00000 000F
p 01 00000 00000 1000
p 01 00000 00000 0171
#
#
p 00 00000 00000 0010
p 01 00000 00000 1000
p 01 00000 00000 0305
#
#
p 00 00000 00000 0011
p 01 00000 00000 1000
p 01 00000 00000 02B8
#
#
p 00 00000 00000 0012
p 01 00000 00000 1000
p 01 00000 00000 02C6
#
#
p 00 00000 00000 0013
p 01 00000 00000 1000
p 01 00000 00000 0245
#
#
p 00 00000 00000 0014
p 01 00000 00000 1000
p 01 00000 00000 0178
#
#
p 00 00000 00000 0015
p 01 00000 00000 1000
p 01 00000 00000 017B
#
#
p 00 00000 00000 0016
p 01 00000 00000 1000
p 01 00000 00000 017F
#
#
p 00 00000 00000 0017
p 01 00000 00000 1000
p 01 00000 00000 017F
#
#
p 00 00000 00000 0018
p 01 00000 00000 1000
p 01 00000 00000 0183
#
#
p 00 00000 00000 0019
p 01 00000 00000 1000
p 01 00000 00000 0183
#
#
p 00 00000 00000 001A
p 01 00000 00000 1000
p 01 00000 00000 0183
#
#
p 00 00000 00000 001B
p 01 00000 00000 1000
p 01 00000 00000 0183
#
#
p 00 00000 00000 001C
p 01 00000 00000 1000
p 01 00000 00000 0183
#
#
p 00 00000 00000 001D
p 01 00000 00000 1000
p 01 00000 00000 0183
#
#
p 00 00000 00000 001E
p 01 00000 00000 1000
p 01 00000 00000 0183
#
#
p 00 00000 00000 001F
p 01 00000 00000 1000
p 01 00000 00000 0183
#
#
p 00 00000 00000 0020
p 01 00000 00000 1000
p 01 00000 00000 02FD
#
#
p 00 00000 00000 0021
p 01 00000 00000 1000
p 01 00000 00000 02BC
#
#
p 00 00000 00000 0022
p 01 00000 00000 1000
p 01 00000 00000 0397
#
#
p 00 00000 00000 0023
p 01 00000 00000 1000
p 01 00000 00000 024D
#
#
p 00 00000 00000 0024
p 01 00000 00000 1000
p 01 00000 00000 01D3
#
#
p 00 00000 00000 0025
p 01 00000 00000 1000
p 01 00000 00000 01D6
#
#
p 00 00000 00000 0026
p 01 00000 00000 1000
p 01 00000 00000 01FA
#
#
p 00 00000 00000 0027
p 01 00000 00000 1000
p 01 00000 00000 01FA
#
#
p 00 00000 00000 0028
p 01 00000 00000 1000
p 01 00000 00000 01DA
#
#
p 00 00000 00000 0029
p 01 00000 00000 1000
p 01 00000 00000 01DA
#
#
p 00 00000 00000 002A
p 01 00000 00000 1000
p 01 00000 00000 01DA
#
#
p 00 00000 00000 002B
p 01 00000 00000 1000
p 01 00000 00000 01DA
#
#
p 00 00000 00000 002C
p 01 00000 00000 1000
p 01 00000 00000 01DA
#
#
p 00 00000 00000 002D
p 01 00000 00000 1000
p 01 00000 00000 01DA
#
#
p 00 00000 00000 002E
p 01 00000 00000 1000
p 01 00000 00000 01DA
#
#
p 00 00000 00000 002F
p 01 00000 00000 1000
p 01 00000 00000 01DA
#
#
p 00 00000 00000 0030
p 01 00000 00000 1000
p 01 00000 00000 0301
#
#
p 00 00000 00000 0031
p 01 00000 00000 1000
p 01 00000 00000 02B8
#
#
p 00 00000 00000 0032
p 01 00000 00000 1000
p 01 00000 00000 0390
#
#
p 00 00000 00000 0033
p 01 00000 00000 1000
p 01 00000 00000 0254
#
#
p 00 00000 00000 0034
p 01 00000 00000 1000
p 01 00000 00000 01C2
#
#
p 00 00000 00000 0035
p 01 00000 00000 1000
p 01 00000 00000 01DC
#
#
p 00 00000 00000 0036
p 01 00000 00000 1000
p 01 00000 00000 01DF
#
#
p 00 00000 00000 0037
p 01 00000 00000 1000
p 01 00000 00000 01DF
#
#
p 00 00000 00000 0038
p 01 00000 00000 1000
p 01 00000 00000 01E1
#
#
p 00 00000 00000 0039
p 01 00000 00000 1000
p 01 00000 00000 01E1
#
#
p 00 00000 00000 003A
p 01 00000 00000 1000
p 01 00000 00000 01E1
#
#
p 00 00000 00000 003B
p 01 00000 00000 1000
p 01 00000 00000 01E1
#
#
p 00 00000 00000 003C
p 01 00000 00000 1000
p 01 00000 00000 01E1
#
#
p 00 00000 00000 003D
p 01 00000 00000 1000
p 01 00000 00000 01E1
#
#
p 00 00000 00000 003E
p 01 00000 00000 1000
p 01 00000 00000 01E1
#
#
p 00 00000 00000 003F
p 01 00000 00000 1000
p 01 00000 00000 01E1
#
#
p 00 00000 00000 0040
p 01 00000 00000 1000
p 01 00000 00000 027B
#
#
p 00 00000 00000 0041
p 01 00000 00000 1000
p 01 00000 00000 02BC
#
#
p 00 00000 00000 0042
p 01 00000 00000 1000
p 01 00000 00000 021D
#
#
p 00 00000 00000 0043
p 01 00000 00000 1000
p 01 00000 00000 020E
#
#
p 00 00000 00000 0044
p 01 00000 00000 1000
p 01 00000 00000 0205
#
#
p 00 00000 00000 0045
p 01 00000 00000 1000
p 01 00000 00000 0139
#
#
p 00 00000 00000 0046
p 01 00000 00000 1000
p 01 00000 00000 013D
#
#
p 00 00000 00000 0047
p 01 00000 00000 1000
p 01 00000 00000 013D
#
#
p 00 00000 00000 0048
p 01 00000 00000 1000
p 01 00000 00000 013F
#
#
p 00 00000 00000 0049
p 01 00000 00000 1000
p 01 00000 00000 013F
#
#
p 00 00000 00000 004A
p 01 00000 00000 1000
p 01 00000 00000 013F
#
#
p 00 00000 00000 004B
p 01 00000 00000 1000
p 01 00000 00000 013F
#
#
p 00 00000 00000 004C
p 01 00000 00000 1000
p 01 00000 00000 013F
#
#
p 00 00000 00000 004D
p 01 00000 00000 1000
p 01 00000 00000 013F
#
#
p 00 00000 00000 004E
p 01 00000 00000 1000
p 01 00000 00000 013F
#
#
p 00 00000 00000 004F
p 01 00000 00000 1000
p 01 00000 00000 013F
#
#
p 00 00000 00000 0050
p 01 00000 00000 1000
p 01 00000 00000 0278
#
#
p 00 00000 00000 0051
p 01 00000 00000 1000
p 01 00000 00000 02B8
#
#
p 00 00000 00000 0052
p 01 00000 00000 1000
p 01 00000 00000 0221
#
#
p 00 00000 00000 0053
p 01 00000 00000 1000
p 01 00000 00000 0213
#
#
p 00 00000 00000 0054
p 01 00000 00000 1000
p 01 00000 00000 0208
#
#
p 00 00000 00000 0055
p 01 00000 00000 1000
p 01 00000 00000 0141
#
#
p 00 00000 00000 0056
p 01 00000 00000 1000
p 01 00000 00000 0145
#
#
p 00 00000 00000 0057
p 01 00000 00000 1000
p 01 00000 00000 0145
#
#
p 00 00000 00000 0058
p 01 00000 00000 1000
p 01 00000 00000 0147
#
#
p 00 00000 00000 0059
p 01 00000 00000 1000
p 01 00000 00000 0147
#
#
p 00 00000 00000 005A
p 01 00000 00000 1000
p 01 00000 00000 0147
#
#
p 00 00000 00000 005B
p 01 00000 00000 1000
p 01 00000 00000 0147
#
#
p 00 00000 00000 005C
p 01 00000 00000 1000
p 01 00000 00000 0147
#
#
p 00 00000 00000 005D
p 01 00000 00000 1000
p 01 00000 00000 0147
#
#
p 00 00000 00000 005E
p 01 00000 00000 1000
p 01 00000 00000 0147
#
#
p 00 00000 00000 005F
p 01 00000 00000 1000
p 01 00000 00000 0147
#
# 
p 00 00000 00000 0060
p 01 00000 00000 1000
p 01 00000 00000 0272
#
#
p 00 00000 00000 0061
p 01 00000 00000 1000
p 01 00000 00000 02BC
#
#
p 00 00000 00000 0062
p 01 00000 00000 1000
p 01 00000 00000 0225
#
#
p 00 00000 00000 0063
p 01 00000 00000 1000
p 01 00000 00000 0218
#
#
p 00 00000 00000 0064
p 01 00000 00000 1000
p 01 00000 00000 020B
#
#
p 00 00000 00000 0065
p 01 00000 00000 1000
p 01 00000 00000 0149
#
#
p 00 00000 00000 0066
p 01 00000 00000 1000
p 01 00000 00000 014D
#
#
p 00 00000 00000 0067
p 01 00000 00000 1000
p 01 00000 00000 014D
#
#
p 00 00000 00000 0068
p 01 00000 00000 1000
p 01 00000 00000 014F
#
#
p 00 00000 00000 0069
p 01 00000 00000 1000
p 01 00000 00000 014F
#
#
p 00 00000 00000 006A
p 01 00000 00000 1000
p 01 00000 00000 014F
#
#
p 00 00000 00000 006B
p 01 00000 00000 1000
p 01 00000 00000 014F
#
#
p 00 00000 00000 006C
p 01 00000 00000 1000
p 01 00000 00000 014F
#
#
p 00 00000 00000 006D
p 01 00000 00000 1000
p 01 00000 00000 014F
#
#
p 00 00000 00000 006E
p 01 00000 00000 1000
p 01 00000 00000 014F
#
#
p 00 00000 00000 006F
p 01 00000 00000 1000
p 01 00000 00000 014F
#
#
p 00 00000 00000 0070
p 01 00000 00000 1000
p 01 00000 00000 0275
#
#
p 00 00000 00000 0071
p 01 00000 00000 1000
p 01 00000 00000 02B8
#
#
p 00 00000 00000 0072
p 01 00000 00000 1000
p 01 00000 00000 030D
#
#
p 00 00000 00000 0073
p 01 00000 00000 1000
p 01 00000 00000 027E
#
#
p 00 00000 00000 0074
p 01 00000 00000 1000
p 01 00000 00000 0194
#
#
p 00 00000 00000 0075
p 01 00000 00000 1000
p 01 00000 00000 0198
#
#
p 00 00000 00000 0076
p 01 00000 00000 1000
p 01 00000 00000 019E
#
#
p 00 00000 00000 0077
p 01 00000 00000 1000
p 01 00000 00000 019E
#
#
p 00 00000 00000 0078
p 01 00000 00000 1000
p 01 00000 00000 01A3
#
#
p 00 00000 00000 0079
p 01 00000 00000 1000
p 01 00000 00000 01A3
#
#
p 00 00000 00000 007A
p 01 00000 00000 1000
p 01 00000 00000 01A3
#
#
p 00 00000 00000 007B
p 01 00000 00000 1000
p 01 00000 00000 01A3
#
#
p 00 00000 00000 007C
p 01 00000 00000 1000
p 01 00000 00000 01A3
#
#
p 00 00000 00000 007D
p 01 00000 00000 1000
p 01 00000 00000 01A3
#
#
p 00 00000 00000 007E
p 01 00000 00000 1000
p 01 00000 00000 01A3
#
#
p 00 00000 00000 007F
p 01 00000 00000 1000
p 01 00000 00000 01A3
#
#
p 00 00000 00000 0080
p 01 00000 00000 1000
p 01 00000 00000 0268
#
#
p 00 00000 00000 0081
p 01 00000 00000 1000
p 01 00000 00000 02BC
#
#
p 00 00000 00000 0082
p 01 00000 00000 1000
p 01 00000 00000 0317
#
#
p 00 00000 00000 0083
p 01 00000 00000 1000
p 01 00000 00000 0265
#
#
p 00 00000 00000 0084
p 01 00000 00000 1000
p 01 00000 00000 036F
#
#
p 00 00000 00000 0085
p 01 00000 00000 1000
p 01 00000 00000 0187
#
#
p 00 00000 00000 0086
p 01 00000 00000 1000
p 01 00000 00000 018D
#
#
p 00 00000 00000 0087
p 01 00000 00000 1000
p 01 00000 00000 018D
#
#
p 00 00000 00000 0088
p 01 00000 00000 1000
p 01 00000 00000 0192
#
#
p 00 00000 00000 0089
p 01 00000 00000 1000
p 01 00000 00000 0192
#
#
p 00 00000 00000 008A
p 01 00000 00000 1000
p 01 00000 00000 0192
#
#
p 00 00000 00000 008B
p 01 00000 00000 1000
p 01 00000 00000 0192
#
#
p 00 00000 00000 008C
p 01 00000 00000 1000
p 01 00000 00000 0192
#
#
p 00 00000 00000 008D
p 01 00000 00000 1000
p 01 00000 00000 0192
#
#
p 00 00000 00000 008E
p 01 00000 00000 1000
p 01 00000 00000 0192
#
#
p 00 00000 00000 008F
p 01 00000 00000 1000
p 01 00000 00000 0192
#
#
p 00 00000 00000 0090
p 01 00000 00000 1000
p 01 00000 00000 0231
#
#
p 00 00000 00000 0091
p 01 00000 00000 1000
p 01 00000 00000 02B8
#
#
p 00 00000 00000 0092
p 01 00000 00000 1000
p 01 00000 00000 0325
#
#
p 00 00000 00000 0093
p 01 00000 00000 1000
p 01 00000 00000 025F
#
#
p 00 00000 00000 0094
p 01 00000 00000 1000
p 01 00000 00000 01E3
#
#
p 00 00000 00000 0095
p 01 00000 00000 1000
p 01 00000 00000 01FC
#
#
p 00 00000 00000 0096
p 01 00000 00000 1000
p 01 00000 00000 01F6
#
#
p 00 00000 00000 0097
p 01 00000 00000 1000
p 01 00000 00000 01F6
#
#
p 00 00000 00000 0098
p 01 00000 00000 1000
p 01 00000 00000 01F8
#
#
p 00 00000 00000 0099
p 01 00000 00000 1000
p 01 00000 00000 01F8
#
#
p 00 00000 00000 009A
p 01 00000 00000 1000
p 01 00000 00000 01F8
#
#
p 00 00000 00000 009B
p 01 00000 00000 1000
p 01 00000 00000 01F8
#
#
p 00 00000 00000 009C
p 01 00000 00000 1000
p 01 00000 00000 01F8
#
#
p 00 00000 00000 009D
p 01 00000 00000 1000
p 01 00000 00000 01F8
#
#
p 00 00000 00000 009E
p 01 00000 00000 1000
p 01 00000 00000 01F8
#
#
p 00 00000 00000 009F
p 01 00000 00000 1000
p 01 00000 00000 01F8
#
#
p 00 00000 00000 00A0
p 01 00000 00000 1000
p 01 00000 00000 0312
#
#
p 00 00000 00000 00A1
p 01 00000 00000 1000
p 01 00000 00000 02BC
#
#
p 00 00000 00000 00A2
p 01 00000 00000 1000
p 01 00000 00000 0321
#
#
p 00 00000 00000 00A3
p 01 00000 00000 1000
p 01 00000 00000 023A
#
#
p 00 00000 00000 00A4
p 01 00000 00000 1000
p 01 00000 00000 0350
#
#
p 00 00000 00000 00A5
p 01 00000 00000 1000
p 01 00000 00000 0101
#
#
p 00 00000 00000 00A6
p 01 00000 00000 1000
p 01 00000 00000 015D
#
#
p 00 00000 00000 00A7
p 01 00000 00000 1000
p 01 00000 00000 015D
#
#
p 00 00000 00000 00A8
p 01 00000 00000 1000
p 01 00000 00000 0163
#
#
p 00 00000 00000 00A9
p 01 00000 00000 1000
p 01 00000 00000 0163
#
#
p 00 00000 00000 00AA
p 01 00000 00000 1000
p 01 00000 00000 0163
#
#
p 00 00000 00000 00AB
p 01 00000 00000 1000
p 01 00000 00000 0163
#
#
p 00 00000 00000 00AC
p 01 00000 00000 1000
p 01 00000 00000 0163
#
#
p 00 00000 00000 00AD
p 01 00000 00000 1000
p 01 00000 00000 0163
#
#
p 00 00000 00000 00AE
p 01 00000 00000 1000
p 01 00000 00000 0163
#
#
p 00 00000 00000 00AF
p 01 00000 00000 1000
p 01 00000 00000 0163
#
#
p 00 00000 00000 00B0
p 01 00000 00000 1000
p 01 00000 00000 031C
#
#
p 00 00000 00000 00B1
p 01 00000 00000 1000
p 01 00000 00000 02B8
#
#
p 00 00000 00000 00B2
p 01 00000 00000 1000
p 01 00000 00000 02DD
#
#
p 00 00000 00000 00B3
p 01 00000 00000 1000
p 01 00000 00000 01FF
#
#
p 00 00000 00000 00B4
p 01 00000 00000 1000
p 01 00000 00000 0280
#
#
p 00 00000 00000 00B5
p 01 00000 00000 1000
p 01 00000 00000 0295
#
#
p 00 00000 00000 00B6
p 01 00000 00000 1000
p 01 00000 00000 028F
#
#
p 00 00000 00000 00B7
p 01 00000 00000 1000
p 01 00000 00000 028F
#
#
p 00 00000 00000 00B8
p 01 00000 00000 1000
p 01 00000 00000 0292
#
#
p 00 00000 00000 00B9
p 01 00000 00000 1000
p 01 00000 00000 0292
#
#
p 00 00000 00000 00BA
p 01 00000 00000 1000
p 01 00000 00000 0292
#
#
p 00 00000 00000 00BB
p 01 00000 00000 1000
p 01 00000 00000 0292
#
#
p 00 00000 00000 00BC
p 01 00000 00000 1000
p 01 00000 00000 0292
#
#
p 00 00000 00000 00BD
p 01 00000 00000 1000
p 01 00000 00000 0292
#
#
p 00 00000 00000 00BE
p 01 00000 00000 1000
p 01 00000 00000 0292
#
#
p 00 00000 00000 00BF
p 01 00000 00000 1000
p 01 00000 00000 0292
#
#
p 00 00000 00000 00C0
p 01 00000 00000 1000
p 01 00000 00000 02AA
#
#
p 00 00000 00000 00C1
p 01 00000 00000 1000
p 01 00000 00000 02BC
#
#
p 00 00000 00000 00C2
p 01 00000 00000 1000
p 01 00000 00000 02F9
#
#
p 00 00000 00000 00C3
p 01 00000 00000 1000
p 01 00000 00000 0201
#
#
p 00 00000 00000 00C4
p 01 00000 00000 1000
p 01 00000 00000 02D0
#
#
p 00 00000 00000 00C5
p 01 00000 00000 1000
p 01 00000 00000 01A5
#
#
p 00 00000 00000 00C6
p 01 00000 00000 1000
p 01 00000 00000 01AC
#
#
p 00 00000 00000 00C7
p 01 00000 00000 1000
p 01 00000 00000 01AC
#
#
p 00 00000 00000 00C8
p 01 00000 00000 1000
p 01 00000 00000 01B1
#
#
p 00 00000 00000 00C9
p 01 00000 00000 1000
p 01 00000 00000 01B1
#
#
p 00 00000 00000 00CA
p 01 00000 00000 1000
p 01 00000 00000 01B1
#
#
p 00 00000 00000 00CB
p 01 00000 00000 1000
p 01 00000 00000 01B1
#
#
p 00 00000 00000 00CC
p 01 00000 00000 1000
p 01 00000 00000 01B1
#
#
p 00 00000 00000 00CD
p 01 00000 00000 1000
p 01 00000 00000 01B1
#
#
p 00 00000 00000 00CE
p 01 00000 00000 1000
p 01 00000 00000 01B1
#
#
p 00 00000 00000 00CF
p 01 00000 00000 1000
p 01 00000 00000 01B1
#
#
p 00 00000 00000 00D0
p 01 00000 00000 1000
p 01 00000 00000 02B6
#
#
p 00 00000 00000 00D1
p 01 00000 00000 1000
p 01 00000 00000 02B8
#
#
p 00 00000 00000 00D2
p 01 00000 00000 1000
p 01 00000 00000 02F6
#
#
p 00 00000 00000 00D3
p 01 00000 00000 1000
p 01 00000 00000 0203
#
#
p 00 00000 00000 00D4
p 01 00000 00000 1000
p 01 00000 00000 0328
#
#
p 00 00000 00000 00D5
p 01 00000 00000 1000
p 01 00000 00000 029F
#
#
p 00 00000 00000 00D6
p 01 00000 00000 1000
p 01 00000 00000 01B3
#
#
p 00 00000 00000 00D7
p 01 00000 00000 1000
p 01 00000 00000 01B3
#
#
p 00 00000 00000 00D8
p 01 00000 00000 1000
p 01 00000 00000 0299
#
#
p 00 00000 00000 00D9
p 01 00000 00000 1000
p 01 00000 00000 0299
#
#
p 00 00000 00000 00DA
p 01 00000 00000 1000
p 01 00000 00000 0299
#
#
p 00 00000 00000 00DB
p 01 00000 00000 1000
p 01 00000 00000 0299
#
#
p 00 00000 00000 00DC
p 01 00000 00000 1000
p 01 00000 00000 0299
#
#
p 00 00000 00000 00DD
p 01 00000 00000 1000
p 01 00000 00000 0299
#
#
p 00 00000 00000 00DE
p 01 00000 00000 1000
p 01 00000 00000 0299
#
#
p 00 00000 00000 00DF
p 01 00000 00000 1000
p 01 00000 00000 0299
#
#
p 00 00000 00000 00E0
p 01 00000 00000 1000
p 01 00000 00000 0229
#
#
p 00 00000 00000 00E1
p 01 00000 00000 1000
p 01 00000 00000 02BC
#
#
p 00 00000 00000 00E2
p 01 00000 00000 1000
p 01 00000 00000 0133
#
#
p 00 00000 00000 00E3
p 01 00000 00000 1000
p 01 00000 00000 0133
#
#
p 00 00000 00000 00E4
p 01 00000 00000 1000
p 01 00000 00000 01F2
#
#
p 00 00000 00000 00E5
p 01 00000 00000 1000
p 01 00000 00000 0130
#
#
p 00 00000 00000 00E6
p 01 00000 00000 1000
p 01 00000 00000 0133
#
#
p 00 00000 00000 00E7
p 01 00000 00000 1000
p 01 00000 00000 0133
#
#
p 00 00000 00000 00E8
p 01 00000 00000 1000
p 01 00000 00000 0136
#
#
p 00 00000 00000 00E9
p 01 00000 00000 1000
p 01 00000 00000 0136
#
#
p 00 00000 00000 00EA
p 01 00000 00000 1000
p 01 00000 00000 0136
#
#
p 00 00000 00000 00EB
p 01 00000 00000 1000
p 01 00000 00000 0136
#
#
p 00 00000 00000 00EC
p 01 00000 00000 1000
p 01 00000 00000 0136
#
#
p 00 00000 00000 00ED
p 01 00000 00000 1000
p 01 00000 00000 0136
#
#
p 00 00000 00000 00EE
p 01 00000 00000 1000
p 01 00000 00000 0136
#
#
p 00 00000 00000 00EF
p 01 00000 00000 1000
p 01 00000 00000 0136
#
#
p 00 00000 00000 00F0
p 01 00000 00000 1000
p 01 00000 00000 022D
#
#
p 00 00000 00000 00F1
p 01 00000 00000 1000
p 01 00000 00000 02B8
#
#
p 00 00000 00000 00F2
p 01 00000 00000 1000
p 01 00000 00000 0155
#
#
p 00 00000 00000 00F3
p 01 00000 00000 1000
p 01 00000 00000 0155
#
#  
p 00 00000 00000 00F4
p 01 00000 00000 1000
p 01 00000 00000 01F4
#
#
p 00 00000 00000 00F5
p 01 00000 00000 1000
p 01 00000 00000 0151
#
#
p 00 00000 00000 00F6
p 01 00000 00000 1000
p 01 00000 00000 0155
#
#
p 00 00000 00000 00F7
p 01 00000 00000 1000
p 01 00000 00000 0155
#
#
p 00 00000 00000 00F8
p 01 00000 00000 1000
p 01 00000 00000 0159
#
#
p 00 00000 00000 00F9
p 01 00000 00000 1000
p 01 00000 00000 0159
#
#
p 00 00000 00000 00FA
p 01 00000 00000 1000
p 01 00000 00000 0159
#
#
p 00 00000 00000 00FB
p 01 00000 00000 1000
p 01 00000 00000 0159
#
#
p 00 00000 00000 00FC
p 01 00000 00000 1000
p 01 00000 00000 0159
#
#
p 00 00000 00000 00FD
p 01 00000 00000 1000
p 01 00000 00000 0159
#
#
p 00 00000 00000 00FE
p 01 00000 00000 1000
p 01 00000 00000 0159
#
#
p 00 00000 00000 00FF
p 01 00000 00000 1000
p 01 00000 00000 0159
#


# Unreset CPU
p 00 00000 00001 0001
p 01 00000 00001 0000
p 01 00000 00001 0000
# 

# ##################################################################

#
