
;        .PAGE 'DOCUMENTATION, EQUATES, STORAGE'

;        THIS PACKAGE PROVIDES FUNDAMENTAL GRAPHICS ORIENTED
;        SUBROUTINES NEEDED FOR EFFECTIVE USE OF THE VISIBLE MEMORY AS
;        A GRAPHIC DISPLAY DEVICE.  MAJOR SUBROUTINES INCLUDED ARE AS
;        FOLLOWS:
;           CLEAR - CLEARS THE ENTIRE VISIBLE MEMORY AS DEFINED BY
;                   NPIX/8
;           PIXADR- RETURNS BYTE AND BIT ADDRESS OF PIXEL AT X1CORD,
;                   Y1CORD
;           CKCRD1- PERFORM A RANGE CHECK ON X1CORD,Y1CORD
;           CKCRD2- PERFORM A RANGE CHECK ON X2CORD,Y2CORD
;           STPIX - SET PIXEL AT X1CORD,Y1CORD TO A ONE (WHITE DOT)
;           CLPIX - CLEAR PIXEL AT X1CORD,Y1CORD TO ZERO (BLACK DOT)
;           FLPIX - FLIP THE PIXEL AT X1CORD,Y1CORD
;           WRPIX - UPDATE PIXEL AT X1CORD,Y1CORD ACCORDING TO THE
;                   STATE OF THE ACCUMULATOR
;           RDPIX - COPY THE STATE OF THE PIXEL AT X1CORD,Y1CORD INTO
;                   THE ACCUMULATOR
;           DRAW -  DRAW THE BEST STRAIGHT LINE FROM X1CORD,Y1CORD
;                   TO X2CORD,Y2CORD. X2CORD,Y2CORD COPIED TO
;                   X1CORD,Y1CORD AFTER DRAWING
;           ERASE - SAME AS DRAW EXCEPT A BLACK LINE IS DRAWN
;           DCHAR - DISPLAYS A CHARACTER WHOSE UPPER LEFT CORNER IS
;                   X1CORD,Y1CORD. CHARACTER MATRIX IS 5 WIDE BY 9
;                   HIGH INCLUDING LOWER CASE DESCENDERS BUT NOT
;                   INCLUDING CHARACTER AND LINE SPACING.
;           DTEXT - ACCEPTS ASCII CHARACTERS AND FORMATS THEM INTO
;                   TEXT. A STANDARD (BUT EASILY MODIFIED) CHARACTER
;                   FIELD 6 WIDE BY 11 HIGH ALLOWS UP TO 18 LINES OF 53
;                   CHARACTERS. SUBSCRIPT AND SUPERSCRIPT VIA CONTROL
;                   CHARACTERS IS IMPLEMENTED.
;           DTXTIN- INITIALIZE PARAMETERS FOR USE OF DTEXT ON FULL
;                   SCREEN.
;
;        ALL SUBROUTINES DEPEND ON ONE OR TWO PAIRS OF COORDINATES.
;        EACH COORDINATE IS A DOUBLE PRECISION, UNSIGNED NUMBER WITH
;        THE LOW BYTE FIRST (I.E.  LIKE MEMORY ADDRESSES IN THE 6502)
;        THE ORIGIN OF THE COORDINATE SYSTEM IS AT THE LOWER LEFT
;        CORNER OF THE SCREEN THEREFORE THE ENITRE SCREEN IS IN THE
;        FIRST QUADRANT.  ALLOWABLE RANGE OF THE X COORDINATE IS 0 TO
;        319 (DECIMAL) AND THE RANGE OF THE Y COORDINATE IS 0 TO 199.
;        FOR MAXIMUM SPEED ALL SUBROUTINES ASSUME THAT THE COORDINATE
;        VALUES ARE IN RANGE.  IF THEY ARE NOT, WILD STORING INTO ANY
;        PART OF KIM RAM IS POSSIBLE.  FOR DEBUGGING, CALLS TO CKCRD1
;        AND CKCRD2 SHOULD BE PERFORMED PRIOR TO GRAPHIC ROUTINE CALLS
;        IN ORDER TO DETECT AND CORRECT ERRONEOUS COORDINATE VALUES.

;        GENERAL EQUATES

NX       =      320          ; NUMBER OF BITS IN A ROW
NY       =      200          ; NUMBER OF ROWS  (CHANGE FOR HALF SCREEN
                             ; OPERATION)
NPIX     =      NX*NY        ; NUMBER OF PIXELS
CHHIW    =      11           ; HEIGHT OF CHARACTER WINDOW
CHWIDW   =      6            ; WIDTH OF CHARACTER WINDOW
CHHIM    =      9            ; HEIGHT OF CHARACTER MATRIX
CHWIDM   =      5            ; WIDTH OF CHARACTER MATRIX

;        BASE PAGE TEMPORARY STORAGE (MAY BE DESTROYED BETWEEN CALLS)

         *=     $EA

ADP1:    .WORD  ?            ; ADDRESS POINTER 1
ADP2:    .WORD  ?            ; ADDRESS POINTER 2

;        PERMANENT RAM STORAGE  (MUST BE PRESERVED BETWEEN CALLS)
;******* THESE PARAMETERS MUST BE SET BEFORE USING GRAPHIC ************
;******************* ROUTINES THAT REFERENCE THEM *********************

         *=     $100         ; PUT IN STACK AREA FOR CONVENIENCE

VMORG:   .BYTE  ?            ; PAGE NUMBER OF FIRST VISIBLE MEMORY
                             ; LOCATION
X1CORD:  .WORD  ?            ; COORDINATE PAIR 1 AND CURSOR LOCATION
Y1CORD:  .WORD  ?
X2CORD:  .WORD  ?            ; COORDINATE PAIR 2
Y2CORD:  .WORD  ?
TMAR:    .WORD  ?            ; TOP MARGIN FOR DTEXT
BMAR:    .WORD  ?            ; BOTTOM MARGIN FOR DTEXT
LMAR:    .WORD  ?            ; LEFT MARGIN FOR DTEXT
RMAR:    .WORD  ?            ; RIGHT MARGIN FOR DTEXT

;        GENERAL TEMPORARY STORAGE (CAN BE DESTROYED BETWEEN CALLS)

BTPT:    .BYTE  ?            ; BIT NUMBER
DELTAX:  .WORD  ?            ; DELTA X FOR LINE DRAW
DELTAY:  .WORD  ?            ; DELTA Y FOR LINE DRAW
ACC:     .WORD  ?            ; ACCUMULATOR FOR LINE DRAW
XDIR:    .BYTE  ?            ; X MOVEMENT DIRECTION, ZERO=+
YDIR:    .BYTE  ?            ; Y MOVEMENT DIRECTION, ZERO=+
XCHFLG:  .BYTE  ?            ; EXCHANGE X AND Y FLAG, EXCHANGE IF NOT 0
COLOR:   .BYTE  ?            ; COLOR OF LINE DRAWN -1=WHITE
TEMP:    .WORD  ?            ; TEMPORARY STORAGE
TLBYT    =      DELTAX       ; TOP LEFT BYTE ADDRESS FOR TEXT WINDOW
TLBIT    =      XDIR         ; TOP LEFT BIT ADDRESS FOR TEXT WINDOW
TRBYT    =      DELTAY       ; TOP RIGHT BYTE ADDRESS FOR TEXT WINDOW
TRBIT    =      YDIR         ; TOP RIGHT BIT ADDRESS FOR TEXT WINDOW
BRBYT    =      ACC          ; BOTTOM RIGHT BYTE ADDRESS FOR TXT WINDOW

;        .PAGE  'CLEAR ENTIRE SCREEN ROUTINE'
;        CLEAR ENTIRE SCREEN ROUTINE
;        USES BOTH INDICES AND ADP1

         *=     $5500        ; PUT AT END OF 16K EXPANSION

CLEAR:   LDY    #0           ; INITIALIZE ADDRESS POINTER
         STY    ADP1         ; AND ZERO INDEX Y
         LDA    VMORG
         STA    ADP1+1
         CLC                 ; COMPUTE END ADDRESS
         ADC    #NPIX/8/256
         TAX                 ; KEEP IT IN X
CLEAR1:  TYA                 ; CLEAR A BYTE
         STA    (ADP1),Y
         INC    ADP1         ; INCREMENT ADDRESS POINTER
         BNE    CLEAR2
         INC    ADP1+1
CLEAR2:  LDA    ADP1         ; TEST IF DONE
         CMP    #(NPIX/8)&$FF
         BNE    CLEAR1       ; LOOP IF NOT
         CPX    ADP1+1
         BNE    CLEAR1       ; LOOP IF NOT
         RTS                 ; RETURN

;        .PAGE  'PIXADR - BYTE AND BIT ADDRESS OF A PIXEL'
;        PIXADR - FIND THE BYTE ADDRESS AND BIT NUMBER OF PIXEL AT
;                 X1CORD,Y1CORD
;        PUTS BYTE ADDRESS IN ADP1 AND BIT MUMBER (BIT 0 IS LEFTMOST)
;        IN BTPT.
;        DOES NOT CHECK MAGNITUDE OF COORDINATES FOR MAXIMUM SPEED
;        PRESERVES X AND Y REGISTERS, DESTROYS A
;        BYTE ADDRESS = VMORG*256+(199-Y1CORD)*40+INT(XCORD/8)
;        BIT ADDRESS = REM(XCORD/8)
;        OPTIMIZED FOR SPEED THEREFORE CALLS TO A DOUBLE SHIFT ROUTINE
;        ARE NOT DONE

PIXADR:  LDA    X1CORD       ; COMPUTE BIT ADDRESS FIRST
         STA    ADP1         ; ALSO TRANSFER X1CORD TO ADP1
         AND    #$07         ; WHICH IS SIMPLY THE LOW 3 BITS OF X
         STA    BTPT
         LDA    X1CORD+1     ; FINISH TRANSFERRING X1CORD TO ADP1
         STA    ADP1+1
         LSR    ADP1+1       ; DOUBLE SHIFT ADP1 RIGHT 3 TO GET
         ROR    ADP1         ; INT(XCORD/8)
         LSR    ADP1+1
         ROR    ADP1
         LSR    ADP1+1
         ROR    ADP1
         LDA    #199         ; TRANSFER (199-Y1CORD) TO ADP2
         SEC                 ; AND TEMPORARY STORAGE
         SBC    Y1CORD
         STA    ADP2
         STA    TEMP
         LDA    #0
         SBC    Y1CORD+1
         STA    ADP2+1
         STA    TEMP+1
         ASL    ADP2         ; COMPUTE 40*(199-Y1CORD)
         ROL    ADP2+1       ;  2*(199-Y1CORD)
         ASL    ADP2
         ROL    ADP2+1       ;  4*(199+Y1CORD)
         LDA    ADP2         ;  ADD IN TEMPORARY SAVE OF (199-Y1CORD)
         CLC                 ;  TO MAKE 5*(199-Y1CORD)
         ADC    TEMP
         STA    ADP2
         LDA    ADP2+1
         ADC    TEMP+1
         STA    ADP2+1       ;  5*(199-Y1CORD)
         ASL    ADP2         ;  10*(199-Y1CORD)
         ROL    ADP2+1
         ASL    ADP2         ;  20*(199-Y1CORD)
         ROL    ADP2+1
         ASL    ADP2         ;  40*(199-Y1CORD)
         ROL    ADP2+1
         LDA    ADP2         ; ADD IN INT(X1CORD/8) COMPUTED EARLIER
         CLC
         ADC    ADP1
         STA    ADP1
         LDA    ADP2+1
         ADC    ADP1+1
         ADC    VMORG        ; ADD IN VMORG*256
         STA    ADP1+1       ; FINAL RESULT
         RTS                 ; RETURN

;        .PAGE  'INDIVIDUAL PIXEL SUBROUTINES'
;        STPIX - SETS THE PIXEL AT X1CORD,Y1CORD TO A ONE (WHITE DOT)
;        DOES NOT ALTER X1CORD OR Y1CORD
;        PRESERVES X AND Y
;        ASSUMES IN RANGE CORRDINATES

STPIX:   JSR    PIXADR       ; GET BYTE ADDRESS AND BIT NUMBER OF PIXEL
                             ; INTO ADP1
         TYA                 ; SAVE Y
         PHA
         LDY    BTPT         ; GET BIT NUMBER IN Y
         LDA    MSKTB1,Y     ; GET A BYTE WITH THAT BIT =1, OTHERS =0
         LDY    #0           ; ZERO Y
         ORA    (ADP1),Y     ; COMBINE THE BIT WITH THE ADDRESSED VM
         STA    (ADP1),Y     ; BYTE
         PLA                 ; RESTORE Y
         TAY
         RTS                 ; AND RETURN

;        CLPIX - CLEARS THE PIXEL AT X1CORD,Y1CORD TO A ZERO (BLACK DOT
;        DOES NOT ALTER X1CORD OR Y1CORD
;        PRESERVES X AND Y
;        ASSUMES IN RANGE COORDINATES

CLPIX:   JSR    PIXADR       ; GET BYTE ADDRESS AND BIT NUMBER OF PIXEL
                             ; INTO ADP1
         TYA                 ; SAVE Y
         PHA
         LDY    BTPT         ; GET BIT NUMBER IN Y
         LDA    MSKTB2,Y     ; GET A BYTE WITH THAT BIT =0, OTHERS =1
         LDY    #0           ; ZERO Y
         AND    (ADP1),Y     ; REMOVE THE BIT FROM THE ADDRESSED VM
CLPIX1:  STA    (ADP1),Y     ; BYTE
         PLA                 ; RESTORE Y
         TAY
         RTS                 ; AND RETURN

;        FLPIX - FLIPS THE PIXEL AT X1CORD,Y1CORD
;        DOES NOT ALTER X1CORD OR Y1CORD
;        PRESERVES X AND Y
;        ASSUMES IN RANGE COORDINATES

FLPIX:   JSR    PIXADR       ; GET BYTE ADDRESS AND BIT NUMBER OF PIXEL
                             ; INTO ADP1
         TYA                 ; SAVE Y
         PHA
         LDY    BTPT         ; GET BIT NUMBER IN Y
         LDA    MSKTB1,Y     ; GET A BYTE WITH THAT BIT =1, OTHERS =0
         LDY    #0           ; ZERO Y
         EOR    (ADP1),Y     ; FLIP THAT BIT IN THE ADDRESSED VM BYTE
         STA    (ADP1),Y
         PLA                 ; RESTORE Y
         TAY
         RTS                 ; AND RETURN

;        WRPIX - SETS THE PIXEL AT X1CORD,Y1CORD ACCORDING TO THE STATE
;        OF BIT 0 (RIGHTMOST) OF A
;        DOES NOT ALTER X1CORD OR Y1CORD
;        PRESERVES X AND Y AND A
;        ASSUMES IN RANGE CORRDINATES

WRPIX:   BIT    WRPIXM       ; TEST LOW BIT OF A
         PHA
         BEQ    WRPIX1       ; JUMP IF A ZERO TO BE WRITTEN
         JSR    STPIX        ; OTHERWISE WRITE A ONE
         PLA                 ; RESTORE A AND RETURN
         RTS
WRPIX1:  JSR    CLPIX        ; CLEAR THE PIXEL
         PLA                 ; RESTORE A AND RETURN
         RTS

WRPIXM:  .BYTE  1            ; BIT TEST MASK FOR BIT 0

;        RDPIX - READS THE PIXEL AT X1CORD,Y1CORD AND SETS A TO ALL
;        ZEROES IF IT IS A ZERO OR TO ALL ONES IF IT IS A ONE
;        LOW BYTE OF ADP1 IS EQUAL TO A ON RETURN
;        DOES NOT ALTER X1CORD OR Y1CORD
;        PRESERVES X AND Y
;        ASSUMES IN RANGE CORRDINATES

RDPIX:   JSR    PIXADR       ; GET BYTE AND BIT ADDRESS OF PIXEL
         TYA                 ; SAVE Y
         PHA
         LDY    #0           ; GET ADDRESSED BYTE FROM VM
         LDA    (ADP1),Y
         LDY    BTPT         ; GET BIT NUMBER IN Y
         AND    MSKTB1,Y     ; CLEAR ALL BUT ADDRESSED BIT
         BEQ    RDPIX1       ; SKIP AHEAD IF IT WAS A ZERO
         LDA    #$FF         ; SET TO ALL ONES IF IT WAS A ONE
RDPIX1:  STA    ADP1         ; SAVE A TEMPORARILY IN ADP1 WHILE
         PLA                 ; RESTORING Y
         TAY
         LDA    ADP1
         RTS                 ; RETURN

;        MASK TABLES FOR INDIVIDUAL PIXEL SUBROUTINES
;        MSKTB1 IS A TABLE OF 1 BITS CORRESPONDING TO BIT NUMBERS
;        MSKTB2 IS A TABLE OF 0 BITS CORRESPONDING TO BIT NUMBERS

MSKTB1:  .BYTE  $80,$40,$20,$10
         .BYTE  $08,$04,$02,$01
MSKTB2:  .BYTE  $7F,$BF,$DF,$EF
         .BYTE  $F7,$FB,$FD,$FE

;        .PAGE  'COORDINATE CHECK ROUTINES'
;        CKCRD1 - CKECK X1CORD,Y1CORD TO VERIFY THAT THEY ARE IN THE
;                 PROPER RANGE.  IF NOT, THEY ARE REPLACED BY A VALUE
;                 MODULO THE MAXIMUM VALUE+1.
;        NOTE THAT THESE ROUTINES CAN BE VERY SLOW WHEN CORRECTIONS ARE
;        NECESSARY BECAUSE A BRUTE FORCE DIVISON ROUTINE IS USED TO
;        COMPUTE THE MODULUS.
;        FOR MAXIMUM FLEXIBILITY IN USE, ALL REGISTERS ARE PRESERVED

CKCRD1:  PHA                 ; SAVE ALL REGISTERS
         TXA
         PHA
         TYA
         PHA
         LDX    #X1CORD-X1CORD ; CHECK X1CORD
         LDY    #XLIMIT-LIMTAB
         JSR    CK
         LDX    #Y1CORD-X1CORD ; CHECK Y1CORD
         LDY    #YLIMIT-LIMTAB
         JSR    CK
CKCRDR:  PLA                 ; RESTORE REGISTERS
         TAY
         PLA
         TAX
         PLA
         RTS                 ; AND RETURN

;        CKCRD2 - SAME AS CKCRD1 EXCEPT CHECKS X2CORD,Y2CORD

CKCRD2:  PHA                 ; SAVE ALL REGISTERS
         TXA
         PHA
         TYA
         PHA
         LDX    #X2CORD-X1CORD ; CHECK X2CORD
         LDY    #XLIMIT-LIMTAB
         JSR    CK
         LDX    #Y2CORD-X1CORD ; CHECK Y2CORD
         LDY    #YLIMIT-LIMTAB
         JSR    CK
         JMP    CKCRDR       ; GO RESTORE REGISTERS AND RETURN

CK:      LDA    X1CORD+1,X   ; CHECK UPPER BYTE
         CMP    LIMTAB+1,Y   ; AGAINST UPPER BYTE OF LIMIT
         BCC    CK4          ; OK IF LESS THAN UPPER BYTE OF LIMIT
         BEQ    CK3          ; GO CHECK LOWER BYTE IF EQUAL TO
                             ; UPPER BYTE OF LIMIT
CK2:     LDA    X1CORD,X     ; SUBTRACT THE LIMIT
         SEC                 ; LOWER BYTE FIRST
         SBC    LIMTAB,Y
         STA    X1CORD,X
         LDA    X1CORD+1,X
         SBC    LIMTAB+1,Y
         STA    X1CORD+1,X
         JMP    CK           ; AND THEN GO CHECK RANGE AGAIN
CK3:     LDA    X1CORD,X     ; CHECK LOWER BYTE OF X
         CMP    LIMTAB,Y
         BCS    CK2          ; GO ADJUST IF TOO LARGE
CK4:     RTS                 ; RETURN

LIMTAB:                      ; TABLE OF LIMITS
XLIMIT:  .WORD  NX
YLIMIT:  .WORD  NY

;        .PAGE  'LINE DRAWING ROUTINES'
;        DRAW - DRAW THE BEST STRAIGHT LINE FROM X1CORD,Y1CORD TO
;        X2CORD, Y2CORD.
;        X2CORD,Y2CORD COPIED TO X1CORD,Y1CORD AFTER DRAWING
;        PRESERVES X AND Y
;        USES AN ALGORITHM THAT REQUIRES NO MULTIPLICATION OR DIVISON

ERASE:   LDA    #$00         ; SET LINE COLOR TO BLACK
         BEQ    DRAW1        ; GO DRAW THE LINE

DRAW:    LDA    #$FF         ; SET LINE COLOR TO WHITE
DRAW1:   STA    COLOR
         TXA                 ; SAVE X AND Y
         PHA
         TYA
         PHA

;        COMPUTE SIGN AND MAGNITUDE OF DELTA X = X2-X1
;        PUT MAGNITUDE IN DELTAX AND SIGN IN XDIR

         LDA    #0           ; FIRST ZERO DIR
         STA    XDIR
         LDA    X2CORD       ; NEXT COMPUTE TWOS COMPLEMENT DIFFERENCE
         SEC
         SBC    X1CORD
         STA    DELTAX
         LDA    X2CORD+1
         SBC    X1CORD+1
         STA    DELTAX+1
         BPL    DRAW2        ; SKIP AHEAD IF DIFFERENCE IS POPSITIVE
         DEC    XDIR         ; SET XDIR TO -1
         SEC                 ; NEGATE DELTAX
         LDA    #0
         SBC    DELTAX
         STA    DELTAX
         LDA    #0
         SBC    DELTAX+1
         STA    DELTAX+1

;        COMPUTE SIGN AND MAGNITUDE OF DELTA Y = Y2-Y1
;        PUT MAGNITUDE IN DELTAY AND SIGN IN YDIR

DRAW2:   LDA    #0           ; FIRST ZERO YDIR
         STA    YDIR
         LDA    Y2CORD       ; NEXT COMPUTE TWOS COMPLEMENT DIFFERENCE
         SEC
         SBC    Y1CORD
         STA    DELTAY
         LDA    Y2CORD+1
         SBC    Y1CORD+1
         STA    DELTAY+1
         BPL    DRAW3        ; SKI AHEAD IF DIFFERENCE IS POSITIVE
         DEC    YDIR         ; SET YDIR TO -1
         SEC                 ; NEGATE DELTAX
         LDA    #0
         SBC    DELTAY
         STA    DELTAY
         LDA    #0
         SBC    DELTAY+1
         STA    DELTAY+1

;        DETERMINE IF DELTAY IS LARGER THAN DELTAX
;        IF SO, EXCHANGE DELTAY AND DELTAX AND SET XCHFLG NONZERO
;        ALSO INITIALIZE ACC TO DELTAX
;        PUT A DOT AT THE INITIAL DENPOINT

DRAW3:   LDA    #0           ; FIRST ZERO XCHFLG
         STA    XCHFLG
         LDA    DELTAY       ; COMPARE DELTAY WITH DELTAX
         SEC
         SBC    DELTAX
         LDA    DELTAY+1
         SBC    DELTAX+1
         BCC    DRAW4        ; SKIP EXCHANGE IF DELTAX IS GREATER THAN
                             ; DELTAY
         LDX    DELTAY       ; EXCHANGE DELTAX AND DELTAY
         LDA    DELTAX
         STA    DELTAY
         STX    DELTAX
         LDX    DELTAY+1
         LDA    DELTAX+1
         STA    DELTAY+1
         STX    DELTAX+1
         DEC    XCHFLG       ; SET XCHFLG TO -1
DRAW4:   LDA    DELTAX       ; INITIALIZE ACC TO DELTAX
         STA    ACC
         LDA    DELTAX+1
         STA    ACC+1
         LDA    COLOR        ; PUT A DOT AT THE INITIAL ENDPOINT
         JSR    WRPIX        ; X1CORD,Y1CORD

;        HEAD OF MAIN DRAWING LOOP
;        TEST IF DONE

DRAW45:  LDA    XCHFLG       ; TEST IF X AND Y EXCHANGED
         BNE    DRAW5        ; JUMP AHEAD IF SO
         LDA    X1CORD       ; TEST FOR X1CORD=X2CORD
         CMP    X2CORD
         BNE    DRAW7        ; GO FOR ANOTHER ITERATION IF NOT
         LDA    X1CORD+1
         CMP    X2CORD+1
         BNE    DRAW7        ; GO FOR ANOTHER ITERATION IF NOT
         BEQ    DRAW6        ; GO RETURN IF SO
DRAW5:   LDA    Y1CORD       ; TEST FOR Y1CORD=Y2CORD
         CMP    Y2CORD
         BNE    DRAW7        ; GO FOR ANOTHER ITERATION IF NOT
         LDA    Y1CORD+1
         CMP    Y2CORD+1
         BNE    DRAW7        ; GO FOR ANOTHER ITERATION IF NOT
DRAW6:   PLA                 ; RESTORE INDEX REGISTERS
         TAY
         PLA
         TAX
         RTS                 ; AND RETURN

;        DO A CLACULATION TO DETERMINE IF ONE OR BOTH AXES ARE TO BE
;        BUMPED (INCREMENTED OR DECREMENTED ACCORDING TO XDIR AND YDIR)
;        AND DO THE BUMPING

DRAW7:   LDA    XCHFLG       ; TEST IF X AND Y EXCHANGED
         BNE    DRAW8        ; JUMP IF SO
         JSR    BMPX         ; BUMP X IF NOT
         JMP    DRAW9
DRAW8:   JSR    BMPY         ; BUMP Y IF SO
DRAW9:   JSR    SBDY         ; SUBTRACT DY FROM ACC TWICE
         JSR    SBDY
         BPL    DRAW12       ; SKIP AHEAD IF ACC IS NOT NEGATIVE
         LDA    XCHFLG       ; EST IF X AND Y EXCHANGED
         BNE    DRAW10       ; JUMP IF SO
         JSR    BMPY         ; BUMP Y IF NOT
         JMP    DRAW11
DRAW10:  JSR    BMPX         ; BUMP X IF SO
DRAW11:  JSR    ADDX         ; ADD DX TO ACC TWICE
         JSR    ADDX

DRAW12:  LDA    COLOR        ; OUTPUT THE NEW POINT
         JSR    WRPIX
         JMP    DRAW45       ; GO TEST IF DONE

;        SUBROUTINES FOR DRAW

SBDY:    LDA    ACC          ; SUBTRACT DELAY FROM ACC AND PUT RESULT
         SEC                 ; IN ACC
         SBC    DELTAY
         STA    ACC
         LDA    ACC+1
         SBC    DELTAY+1
         STA    ACC+1
         RTS


ADDX:    LDA    ACC          ; ADD DELTAX TO ACC AND PUT RESULT IN ACC
         CLC
         ADC    DELTAX
         STA    ACC
         LDA    ACC+1
         ADC    DELTAX+1
         STA    ACC+1
         RTS


BMPX:    LDA    XDIR         ; BUMP X1CORD BY +1 OR -1 ACCORDING
         BNE    BMPX2        ; XDIR
         INC    X1CORD       ; DOUBLE INCREMENT X1CORD IF XDIR=0
         BNE    BMPX1
         INC    X1CORD+1
BMPX1:   RTS
BMPX2:   LDA    X1CORD       ; DOUBLE DECREMENT X1CORD IF XDIR<>0
         BNE    BMPX3
         DEC    X1CORD+1
BMPX3:   DEC    X1CORD
         RTS


BMPY:    LDY    YDIR         ; BUMP Y1CORD BY +1 OR -1 ACCORDING TO
         BNE    BMPY2        ; YDIR
         INC    Y1CORD       ; DOUBLE INCREMENT Y1CORD IF YDIR=0
         BNE    BMPY1
         INC    Y1CORD+1
BMPY1:   RTS
BMPY2:   LDA    Y1CORD       ; DOUBLE DECREMENT Y1CORD IF YDIR<>0
         BNE    BMPY3
         DEC    Y1CORD+1
BMPY3:   DEC    Y1CORD
         RTS

;        .PAGE  'DCHAR - DRAW A CHARACTER'
;        DCHAR - DRAW A CHARACTER WHOSE UPPER LEFT CORNER IS AT
;        X1CORD,Y1CORD
;        X1CORD AND Y1CORD ARE NOT ALTERED
;        THIS ROUTINE DISPLAYS A 5 BY 9 DOT MATRIX CHARACTER AT THE
;        SPECIFIED LOCATION.  THE 5 BY 9 BLOCK IS CLEARED AND THEN THE
;        CHARACTER IS WRITTEN INTO IT.
;        THE 5 BY 9 MATRIX INCLUDES 2 LINE DESCENDERS ON LOWER CASE
;        CHARACTERS.
;        BOTH INDEX REGISTERS AND THE ACCUMULATOR ARE PRESERVED.
;        THE CHARACTER CODE TO BE DISPLAYED SHOULD BE IN A.
;        ASCII CONTROL CODES ARE IGNORED AND NO DRAWING IS DONE
;        THIS ROUTINE ASSUMES IN RANGE COORDINATES INCLUDING WIDTH AND
;        HEIGHT OF CHARACTER.

DCHAR:   PHA                 ; SAVE REGISTERS
         TXA
         PHA
         TYA
         PHA
         TSX                 ; GET IMPUT CHARACTER BACK
         LDA    $103,X
         AND    #$7F         ; INSURE 7 BIT ASCII INPUT
         SEC
         SBC    #$20         ; TEST IF A CONTROL CHARACTER
         BMI    DCHAR5       ; DO A QUICK RETURN IF SO

;        CALCULATE FONT TABLE ADDRESS FOR CHAR

         PHA                 ; SAVE VERIFIED, ZERO ORIGIN CHAR CODE
         JSR    PIXADR       ; GET BYTE AND BIT ADDRESS OF FIRST SCAN
                             ; LINE OF CHARACTER INTO ADP1 AND BTPT
         PLA                 ; RESTORE ZERO ORIGIN CHARACTER CODE
         STA    ADP2         ; PUT IT INTO ADP2
         LDA    #0
         STA    ADP2+1
         JSR    SADP2L       ; COMPUTE 8*CHARACTER CODE IN ADP2
         JSR    SADP2L
         JSR    SADP2L
         LDA    ADP2         ; ADD IN ORIGIN FOR CHARACTER TABLE
         CLC
         ADC    #CHTB&$FF
         STA    ADP2
         LDA    ADP2+1
         ADC    #CHTB/256
         STA    ADP2+1       ; ADP2 NOW HAS ADDRESS OF TOP ROW OF
                             ; CHARACTER SHAPE


         LDY    #0           ; INITIALIZE Y INDEX = FONT TABLE POINTER
         LDX    #0           ; INITIALIZE X = SCAN LINE COUNTER

;        CLEAR THE FIRST TWO SCAN LINES OF DESCENDING CHARACTERS
;        FOR LOWER CASE "J", PUT IN THE DOT AS A SPECIAL CASE

         LDA    (ADP2),Y     ; GET THE FIRST ROW FROM THE TABLE
         BEQ    DCHAR3       ; SKIP AHEAD IF NOT A DESCENDING CHARACTER
         LDA    ADP2         ; IF DESCENDING, TEST IF LOWER CASE J
         CMP    #(($6A-$20)*8+CHTB)&$FF
         BNE    DCHAR1       ; CLEAR FIRST SCAN LINE IF NOT
         LDA    #$20         ; LOAD THE DOT FOR THE J IF A J
         BNE    DCHAR2
DCHAR1:  LDA    #0           ; DO THE FIRST SCAN LINE
DCHAR2:  JSR    MERGE5
         JSR    DN1SCN       ; GO DOWN 1 SCAN LINE
         INX                 ; COUNT SCAN LINES DONE
         LDA    #0           ; CLEAR THE SECOND SCAN LINE
         JSR    MERGE5
         JSR    DN1SCN       ; GO DOWN ANOTHER SCAN LINE
         INX                 ; COUNT SCAN LINES DONE

;        SCAN QUT THE BODY OF THE CHARACTER

DCHAR3:  INY                 ; GO TO NEXT SCAN LINE OF THE FRONT
         LDA    (ADP2),Y     ; GET THE SCAN LINE
         JSR    MERGE5       ; MERGE IT WITH GRAPHIC MEMORY AT (ADP1)
         JSR    DN1SCN       ; GO DOWN 1 SCAN LINE
         INX                 ; COUNT SCAN LINES OUTPUTTED
         CPY    #7           ; TEST IF WHOLE CHARACTER SCANNED OUT
         BNE    DCHAR3       ; GO SCAN OUT ANOTHER ROW IF NOT
DCHAR4:  CPX    #9           ; TEST IF THE WHOLE CHARACTER CELL SCANNED
         BEQ    DCHAR5       ; JUMP OUT IF SO
         LDA    #0           ; CLEAR TRAILING SCAN LINES ON
         JSR    MERGE5       ; NON-DESDENDING CHARACTERS
         JSR    DN1SCN       ; TO NEXT LINE
         INX                 ; COUNT LINES
         BNE    DCHAR4       ; LOOP UNTIL DONE

;        RESTORE REGISTERS AND RETURN

DCHAR5:  PLA
         TAY
         PLA
         TAX
         PLA
         RTS

;        .PAGE  'GRAPHIC MERGE ROUTINES'
;        MERGEL - MERGE LEFT ROUTINE
;        MERGES ACCUMULATOR CONTENTS WITH A BYTE OF GRAPHIC MEMORY
;        ADDRESSED BY ADP1 AND BTPT.
;        BITS TO THE LEFT OF (BTPT) ARE PRESERVED IN GRAPHIC MEMORY.
;        BIT (BTPT) AND BITS TO THE RIGHT ARE SET EQUAL TO
;        CORRESPONDING BIT POSITIONS IN THE ACCUMULATOR.
;        NO REGISTERS ARE BOTHERED.

MERGEL:  PHA                 ; SAVE REGISTERS
         TXA
         PHA
         TYA
         PHA
         TSX                 ; GET INPUT BACKK
         LDA    $103,X
         LDY    BTPT         ; GET BIT NUMBER INTO Y
         AND    MERGTR-1,Y   ; CLEAR BITS TO BE PRESERVED IN MEMORY
         STA    $103,X       ; FROM A
         LDY    #0           ; CLEAR BITS FROM MEMORY TO BE CHANGED
         LDX    BTPT
         LDA    (ADP1),Y     ; GET MEMORY BYTE
         AND    MERGTL,X     ; CLEAR THE BITS
         TSX                 ; DO THE MERGING
         ORA    $103,X
         STA    (ADP1),Y
         PLA                 ; RESTORE REGISTERS
         TAY
         PLA
         TAX
         PLA
         RTS                 ; RETURN

;        MERGR - MERGE RIGHT ROUTINE
;        MERGES ACCUMULATOR CONTENTS WITH A BYTE OF GRAPHIC MEMORY
;        ADDRESSED BY ADP1 AND BTPT.
;        BITS TO THE RIGHT OF (BTPT) ARE PRESERVED IN GRAPHIC MEMORY.
;        BIT (BTPT) AND BITS TO THE LEFT ARE SET EQUAL TO CORRESPONDING
;        BIT POSITIONS IN THE ACCUMULATOR.
;        NO REGISTERS ARE BOTHERED.

MERGER:  PHA                 ; SAVE REGISTERS
         TXA
         PHA
         TYA
         PHA
         TSX                 ; GET INPUT BACKK
         LDA    $103,X
         LDY    BTPT         ; GET BIT NUMBER INTO Y
         AND    MERGTL-1,Y   ; CLEAR BITS TO BE PRESERVED IN MEMORY
         STA    $103,X       ; FROM A
         LDY    #0           ; CLEAR BITS FROM MEMORY TO BE CHANGED
         LDX    BTPT
         LDA    (ADP1),Y     ; GET MEMORY BYTE
         AND    MERGTR,X     ; CLEAR THE BITS
         TSX                 ; DO THE MERGING
         ORA    $103,X
         STA    (ADP1),Y
         PLA                 ; RESTORE REGISTERS
         TAY
         PLA
         TAX
         PLA
         RTS                 ; RETURN

;        MERGE A ROW OF 5 DOTS WITH GRAPHIC MEMORY STARTING AT BYTE
;        ADDRESS AND BIT NUMBER IN ADP1 AND BTPT
;        5 DOTS TO MERGE LEFT JUSTIFIED IN A
;        PRESERVES X AND Y

MERGE5:  STA    TEMP+1       ; SAVE INPUT DATA
         TYA                 ; SAVE Y
         PHA
         LDY    BTPT         ; OPEN UP A 5 BIT WINDOW IN GRAPHIC MEMORY
         LDA    MERGT5,Y     ; LEFT BITS
         LDY    #0           ; ZERO Y
         AND    (ADP1),Y
         STA    (ADP1),Y
         LDY    BTPT
         LDA    MERGT5+8,Y   ; RIGHT BITS
         LDY    #1
         AND    (ADP1),Y
         STA    (ADP1),Y
         LDA    TEMP+1       ; SHIFT DATA RIGHT TO LINE UP LEFTMOST
         LDY    BTPT         ; DATA BIT WITH LEFTMOST GRAPHIC FIELD
         BEQ    MERGE2       ; SHIFT BTPT TIMES
MERGE1:  LSR    A
         DEY
         BNE    MERGE1
MERGE2:  ORA    (ADP1),Y     ; OVERLAY WITH GRAPHIC MEMORY
         STA    (ADP1),Y
         LDA    #8           ; SHIFT DATA LEFT TO LINE UP RIGHTMOST
         SEC                 ; DATA BIT WITH RIGHTMOST GRAPHIC FIELD
         SBC    BTPT         ; SHIFT (8-BTPT) TIMES
         TAY
         LDA    TEMP+1
MERGE3:  ASL    A
         DEY
         BNE    MERGE3
         INY
         ORA    (ADP1),Y     ; OVERLAY WITH GRAPHIC MEMORY
         STA    (ADP1),Y
         PLA                 ; RESTORE Y
         TAY
         RTS                 ; RETURN

MERGTL:  .BYTE  $00,$80,$C0,$E0   ; MASKS FOR MERGE LEFT
         .BYTE  $F0,$F8,$FC,$FE   ; CLEAR ALL BITS TO THE RIGHT OF
         .BYTE  $FF               ; AND INCLUDING BIT N (0=MSB)

MERGTR:  .BYTE  $7F,$3F,$1F,$0F   ; MASKS FOR MERGE RIGHT
         .BYTE  $07,$03,$01,$00   ; CLEAR ALL BITS TO THE LEFT OF
                                     ; AND INCLUDING BIT N (0=MSB)

MERGT5:  .BYTE  $07,$83,$C1,$E0   ; TABLE OF MASKS FOR OPENING UP
         .BYTE  $F0,$F8,$FC,$FE   ; A 5 BIT WINDOW ANYWHERE
         .BYTE  $FF,$FF,$FF,$FF   ; IN GRAPHIC MEMORY
         .BYTE  $7F,$3F,$1F,$0F

;        .PAGE  'DTEXT - SOPHISTICATED TEXT DISPLAY ROUTINE'
;        DTEXT - SOPHISTICATED TEXT DISPLAY ROUTINE
;        CURSOR IS ADDRESSED IN TERMS OF X AND Y COORDINATES.
;        CURSOR POSITION IS IN X1CORD AND Y1CORD WHICH IS THE
;        COORDINATES OF THE UPPER LEFT CORNER OF THE CHARACTER POINTED
;        TO BY THE CURSOR.
;        CURSOR POSITIONING MAY BE ACCOMPLISHED BY DIRECTLY
;        MODIFYING X1CORD,Y1CORD OR BY ASCII CONTROL CODES OR BY
;        CALLING THE CURSOR MOVEMENT SUBROUTINES DIRECTLY.
;        LIKEWISE BASELINE SHIFT FOR SUB AND SUPERSCRIPT MAY BE DONE
;        DIRECTLY OR WITH CONTROL CHARACTERS.
;        ADDITIONAL CONTROL CHARACTER FUNCTIONS ARE EASILY ADDED BY
;        ADDING ENTRIES TO A DISPATCH TABLE AND CORRESPONDING SERVICE
;        ROUTINES
;        CURSOR IS A NON-BLINKING UNDERLINE

;        CONTROL CODES RECOGNIZED:
;        CR  $0D   SETS CURSOR TO LEFT SCREEN EDGE
;        LF  $0A   MOVES CURSOR DOWN ONE LINE, SCROLLS DISPLAY BOUNDED
;                  BY THE MARGINS UP ONE LINE IF ALREADY ON BOTTOM LINE
;        BS  $08   MOVES CURSOR ONE CHARACTER LEFT
;        FF  $0C   CLEARS SCREEN BETWEEN THE MARGINS AND PUTS CURSOR AT
;                  TOP AND LEFT MARGIN
;        SI  $0F   MOVES BASELINE UP 3 SCAN LINES FOR SUPERSCRIPTS
;        SO  $0E   MOVES BASELINE DOWN 3 SCAN LINES FOR SUBSCRIPTS
;        DC1 $11   MOVES CURSOR LEFT ONE CHARACTER WIDTH
;        DC2 $12   MOVES CURSOR RIGHT ONE CHARACTER WIDTH
;        DC3 $13   MOVES CURSOR UP ONE CHARACTER HEIGHT
;        DC4 $14   MOVES CURSOR DOWN ONE CHARACTER HEIGHT
;                  NO WRAPAROUND OR SCROLLING IS DONE WHEN DC1-DC4 IS
;                  USED TO MOVE THE CURSOR.

;        WHEN CALLS TO DTEXT ARE INTERMINGLED WITH CALLS TO THE GRAPHIC
;        ROUTINES, CSRINS AND CSRDEL SHOULD BE CALLED TO INSERT AND
;        DELETE THE CURSOR RESPECTIVELY.  LIKEWISE THESE ROUTINES
;        SHOULD BE USED WHEN THE USER PROGRAM DIRECTLY MODIFIES THE
;        CURSOR POSITION BY CHANGING X1CORD AND Y1CORD. IF THIS IS
;        NOT DONE, THE CURSOR SYMBOL MAY NOT SHOW UNTIL THE FIRST
;        CHARACTER HAS BEEN DRAWN OR MAY REMAIN AT THE LAST CHARACTER
;        DRAWN.

;        DTEXT USES A VIRTUAL PAGE DEFINED BY TOP, BOTTOM, LEFT, AND
;        RIGHT MARGINS.  CURSOR MOVEMENT, SCROLLING, CLEARING, AND TEXT
;        DISPLAY IS RESTRICTED TO THE AREA DEFINED BY TMAR, BMAR, LMAR,
;        AND RMAR RESPECTIVELY.  VALID MARGIN SETTINGS ARE ASSUMED
;        WHICH MEANS THAT THE MARGINS DEFINE SPACE AT LEAST TWO
;        CHARACTERS WIDE BY ONE LINE HIGH AND THAT ALL OF THEM ARE
;        VALID COORDINATES.  A CONVENIENCE ROUTINE, DTXTIN, MAY BE
;        CALLED TO INITIALIZE THE MARGINS FOR USE OF THE FULL SCREEN IN
;        PURE TEXT DISPLAY APPLICATIONS.

;        AUTOMATIC SCROLLING IS PERFORMED BY THE LINE FEED CONTROL
;        CHARACTER PROCESSOR.  FOR SCROLLING TO FUNCTION PROPERLY, AT
;        LEAST TWO LINES OF CHARACTERS MUST FIT BETWEEN THE TOP AND
;        BOTTOM MARGINS AND SUPERSCRIPTS AND SUBSCRIPTS SHOULD BE
;        AVOIDED UNLESS CHHIW IS REDEFINED TO PROVIDE ENOUGH WINDOW
;        AREA TO HOLD THE SHIFTED CHARACTERS WITHOUT OVERLAP WITH
;        ADJECANT LINES.

;        DTXTIN MAY BE CALLED TO INITIALIZE DTEXT FOR USE AS A FULL
;        SCREEN TEXT DISPLAY ROUTINE.  SETS MARGINS FOR FULL SCREEN
;        OPERATION, CLEARS THE SCREEN, AND SETS THE CURSOR AT THE UPPER
;        LEFT CORNER OF THE SCREEN. THE USER MUST STILL SET VMORG
;        HOWEVER!

;        DTXTIN - CONVENIENT INITIALIZE ROUTINE FOR FULL SCREEN USE OF
;        DTEXT.

DTXTIN:  LDA    #0           ; SET LEFT AND BOTTOM MARGINS TO ZERO
         STA    LMAR
         STA    LMAR+1
         STA    BMAR
         STA    BMAR+1
         LDA    #(NY-1)&$FF  ; SET TOP MARGIN TO TOP OF SCREEN
         STA    TMAR
         LDA    #(NY-1)/256
         STA    TMAR+1
         LDA    #(NX-1)&$FF  ; SET RIGHT MARGIN TO RIGHT EDGE OF SCREEN
         STA    RMAR
         LDA    #(NX-1)/256
         STA    RMAR+1
         LDA    #$0C         ; CLEAR SCREEN AND PUT CURSOR AT UPPER
                             ; LEFT CORNER BY SENDING AN ASCII FF
                             ; CONTROL CHARACTER TO DTEXT.  THEN FALL
                             ; INTO DTEXT.

;        DTEXT - DISPLAY ASCII TEXT ROUTINE
;        ENTER WITH ASCII CHARACTER CODE TO DISPLAY OR INTERPRET IN A.
;        PRESERVES ALL REGISTERS.

DTEXT:   PHA                 ; SAVE THE REGISTERS
         TXA
         PHA
         TYA
         PHA
         TSX                 ; GET INPUT BACK
         LDA    $103,X      ; FROM THE STACK
         AND    #$7F         ; INSURE 7 BIT ASCII INPUT
         CMP    #$20         ; TEST IF A CONTROL CHARACTER
         BMI    DTEXT1       ; JUMP AHEAD IF SO
         JSR    DCHAR        ; FOR A REGULAR TEXT CHARACTER, DISPLAY IT
         JSR    CSRR         ; DO A CURSOR RIGHT
DTEXTR:  PLA                 ; RESTORE THE REGISTERS
         TAY
         PLA
         TAX
         PLA
         RTS                 ; AND RETURN

DTEXT1:  LDX    #0           ; SET UP A LOOP TO SEARCH THE CONTROL

DTEXT2:  CMP    CCTAB,X      ; CHARACTER TABLE FOR A MATCH
         BEQ    DTEXT3       ; JUMP IF A MATCH
         INX                 ; BUMP X TO POINT TO NEXT TABLE ENTRY
         INX
         INX
         CPX    #CCTABE-CCTAB; TEST IF ENTIRE TABLE SEARCHED
         BNE    DTEXT2       ; LOOP IF NOT
         BEQ    DTEXTR       ; GO RETURN IF ENTIRE TABLE SEARCHED

DTEXT3:  LDA    CCTAB+2,X    ; JUMP TO THE ADDRESS IN THE NEXT TWO
         PHA                 ; TABLE BYTES
         LDA    CCTAB+1,X
         PHA
         RTS

;        .PAGE 'SERVICE ROUTINES FOR CONTROL CHARACTERS'
;        SERVICE ROUTINES FOR CONTROL CHARACTERS.  DO THE INDICATED
;        FUNCTION AND JUMP TO DTEXTR TO RESTORE REGISTERS AND RETURN.

;        CRR - CURSOR RIGHT

CRR:     JSR    CSRR         ; NOVE CURSOR RIGHT
         JMP    DTEXTR       ; GO RETURN

;        CRL - CURSOR LEFT AND BACKSPACE

CRL:     JSR    CSRL         ; MOVE CURSOR LEFT
         JMP    DTEXTR       ; GO RETURN

;        CRU - CURSOR UP

CRU:     JSR    CSRU         ; NOVE CURSOR UP
         JMP    DTEXTR       ; GO RETURN

;        CRD - CURSOR DOWD

CRD:     JSR    CSRD         ; NOVE CURSOR DOWN
         JMP    DTEXTR       ; GO RETURN

;        BASUP - SHIFT BASELINE UP 3 SCAN LINES
;        NOTE - NO RANGE CHECK ON THE Y COORDINATE IS MADE
;        BASELINE SHIFTING SHOULD ONLY BE DONE AT A BLANK CHARACTER
;        POSITION

BASUP:   JSR    CSRDEL       ; DELETE CURRENT CURSOR
         LDA    Y1CORD       ; INCREMENT COORDINATE BY 3
         CLC
         ADC    #3
         STA    Y1CORD
         BCC    BASUP1
         INC    Y1CORD+1
BASUP1:  JSR    CSRINS       ; DISPLAY CURSOR AT NEW LOCATION
         JMP    DTEXTR       ; GO RETURN

;        BASDN - SHIFT BASELINE DOEN 3 SCAN LINES
;        NOTE - NO RANGE CHECK ON THE Y COORDINATE IS MADE
;        BASELINE SHIFTING SHOULD ONLY BE DONE AT A BLANK CHARACTER
;        POSITION

BASDN:   JSR    CSRDEL       ; DELETE CURRENT CURSOR
         LDA    Y1CORD       ; INCREMENT COORDINATE BY 3
         SEC
         SBC    #3
         STA    Y1CORD
         BCS    BASDN1
         DEC    Y1CORD+1
BASDN1:  JSR    CSRINS       ; DISPLAY CURSOR AT NEW LOCATION
         JMP    DTEXTR       ; GO RETURN

;        CARRET - CARRIAGE RETURN

CARRET:  JSR    CSRDEL       ; DELETE CURRENT CURSOR
         LDA    LMAR         ; SET X1CORD TO THE LEFT MARGIN
         STA    X1CORD
         LDA    LMAR+1
         STA    X1CORD+1
         JSR    CSRINS       ; DISPLAY CURSOR AT NEW LOCATION
         JMP    DTEXTR       ; GO RETURN

;        LNFED - LINE FEED ROUTINE, SCROLLS IF NOT SUFFICIENT SPACE
;                AT THE BOTTOM FOR A NEW LINE

LNFED:   JSR    DNTST        ; TEST IF CURSOR IS TOO FAR DOWN TO ALLOW
         BCC    LNFED1       ; MOVEMENT
         JSR    CSRD         ; IF OK, DO A SIMPLE CURSOR DOWN
         JMP    DTEXTR       ; AND GO RETURN
LNFED1:  JSR    CSRDEL       ; DELETE CURRENT CURSOR
         JSR    RECTP        ; SAVE CURSOR COORDINATES AND PROCESS
                             ; CORNER DATA
LNFED0:  LDA    TLBYT        ; ADD CHHIW SCAN LINES TO ADDRESS OF TOP
         CLC                 ; LEFT CORNER TO ESTABLISH ADDRESS OF
         ADC    #(CHHIW*NX/8)&$FF ; FIRST SCAN LINE TO SCROLL
         STA    ADP2         ; AND PUT INTO ADP2
         LDA    TLBYT+1
         ADC    #CHHIW*NX/8/256
         STA    ADP2+1

;        MOVE LEFT PARTIAL BYTE

LNFED2:  LDA    TLBYT        ; MOVE CURRENT TOP LEFT BYTE ADDRESS INTO
         STA    ADP1         ; ADP1
         LDA    TLBYT+1
         STA    ADP1+1
         LDA    TLBIT        ; MOVE LEFT BIT ADDRESS TO BTPT
         STA    BTPT
         LDY    #0
         LDA    (ADP2),Y     ; MOVE A PARTIAL BYTE FROM (ADP2)
         JSR    MERGEL       ; TO (ADP1) ACCORDING TO BTPT

;        MOVE FULL BYTES IN THE MIDDLE

LNFED3:  INC    ADP1         ; INCREMENT ADP1
         BNE    LNFED4
         INC    ADP1+1
LNFED4:  INC    ADP2         ; INCREMENT ADP2
         BNE    LNFED5
         INC    ADP2+1
LNFED5:  LDA    ADP1         ; TEST IF EQUAL TO CURRENT TOP RIGHT BYTE
         CMP    TRBYT        ; ADDRESS
         BNE    LNFED6       ; SKIP AHEAD IF NOT
         LDA    ADP1+1
         CMP    TRBYT+1
         BEQ    LNFED7       ; GO TO RIGHT PARTIAL BYTE PROCESSING IF =
LNFED6:  LDA    (ADP2),Y     ; MOVE A BYTE
         STA    (ADP1),Y
         JMP    LNFED3       ; GO PROCESS NEXT BYTE

;        MOVE RIGHT PARTIAL BYTE

LNFED7:  LDA    TRBIT        ; MOVE RIGHT BIT ADDRESS TO BTPT
         STA    BTPT
         LDA    (ADP2),Y     ; MOVE A PARTIAL BYTE FROM (ADP2) TO
         JSR    MERGER       ; (ADP1) ACCORDING TO BTPT
         LDA    ADP2         ; TEST IF ADP2 = BRBYT
         CMP    BRBYT
         BNE    LNFED8       ; JUMP AHEAD IF NOT
         LDA    ADP2+1
         CMP    BRBYT+1
         BNE    LNFED8       ; JUMP AHEAD IF NOT
         BEQ    LNFEDB       ; FINISHED WITH MOVE PART OF SCROLL, GO
                             ; CLEAR AREA LEFT AT BOTTOM OF RECTANGLE

;        PREPARE TO START NEXT LINE

LNFED8:  LDA    TLBYT        ; ADD NX/8 TO TOP LEFT BYTE ADDRESS
         CLC
         ADC    #NX/8
         STA    TLBYT
         BCC    LNFED9
         INC    TLBYT+1
LNFED9:  LDA    TRBYT        ; ADD NX/8 TO TOP RIGHT BYTE ADDRESS
         CLC
         ADC    #NX/8
         STA    TRBYT
         BCC    LNFED0
         INC    TRBYT+1
         JMP    LNFED0       ; GO MOVE NEXT SCAN LINE

;        CLEAR REGION AT BOTTOM OF RECTANGLE FOR NEW LINE OF TEXT
;        AND REINSERT CURSOR

LNFEDB:  JSR    LNCLR        ; DO THE CLEARING
         LDA    X2CORD       ; RESTORE CURSOR COORDINATES
         STA    X1CORD
         LDA    X2CORD+1
         STA    X1CORD+1
         LDA    Y2CORD
         STA    Y1CORD
         LDA    Y2CORD+1
         STA    Y1CORD+1
         JSR    CSRINS       ; INSERT CURSOR AT THE SAME POSITION
         JMP    DTEXTR       ; GO RETURN

;        FMFED - FORM FEED ROUTINE, CLEARS THE SCREEN BETWEEN THE
;                MARGINS AND PLACES CURSOR AT UPPER LEFT CORNER OF
;                RECTANGLE DEFINED BY THE MARGINS.
;        NOTE: ROUTINE MODIFIES BOTH ADDRESS POINTERS AND BOTH SETS OF
;        COORDINATES.

FMFED:   JSR    RECTP        ; PROCESS MARGIN DATA INTO CORNER
                             ; BYTE AND BIT ADDRESSES
         JSR    LNCLR        ; CLEAR THE AREA DEFINED BY THE CORNERS
         LDA    LMAR         ; POSITION CURSOR AT TOP AND LEFT MARGINS
         STA    X1CORD
         LDA    LMAR+1
         STA    X1CORD+1
         LDA    TMAR
         STA    Y1CORD
         LDA    TMAR+1
         STA    Y1CORD+1
         JSR    CSRINS       ; INSERT CURSOR
         JMP    DTEXTR       ; FINISGED WITH FORM FEED

;        .PAGE 'MISCELLANEOUS INTERNAL SUBROUTINES'
;        LNCLR - SUBROUTINE TO CLEAR AREA INSIDE OF THE MARGINS
;        DEFINED BY TLBYT,TLBIT; TRBYT,TRBIT; BRBYT
;        USED BY FORM FEED AND SCROLL TO CLEAR BETWEEN THE MARGINS
;        CLEAR LEFT PARTIAL BYTE
;        USES INDEX Y

LNCLR:   LDA    TLBYT        ; MOVE CURRENT TOP LEFT BYTE ADDRESS INTO
         STA    ADP1         ; ADP1
         LDA    TLBYT+1
         STA    ADP1+1
         LDA    TLBIT        ; MOVE LEFT BIT ADDRESS TO BTPT
         STA    BTPT
         LDA    #0           ; CLEAR LEFT PARTIAL BYTE
         JSR    MERGEL

;        CLEAR FULL BYTES IN THE MIDDLE

LNCLR1:  INC    ADP1         ; INCREMENT ADP1
         BNE    LNCLR2
         INC    ADP1+1
LNCLR2:  LDA    ADP1         ; TEST IF EQUAL TO CURRENT TOP RIGHT BYTE
         CMP    TRBYT        ; ADDRESS
         BNE    LNCLR3       ; SKIP AHEAD IF NOT
         LDA    ADP1+1
         CMP    TRBYT+1
         BEQ    LNCLR4       ; GO TO RIGHT PARTIAL BYTE PROCESSING IF =
LNCLR3:  LDA    #0           ; ZERO A BYTE
         TAY
         STA    (ADP1),Y
         BEQ    LNCLR1       ; LOOP UNTIL ALL FULL BYTES ON THIS LINE
                             ; HAVE BEEN CLEARED

;        CLEAR RIGHT PARTIAL BYTE

LNCLR4:  LDA    TRBIT        ; MOVE RIGHT BIT ADDRESS TO BTPT
         STA    BTPT
         LDA    #0           ; CLEAR RIGHT PARTIAL BYTE
         JSR    MERGER
         LDA    ADP1         ; TEST IF ADP1 = BRBYT
         CMP    BRBYT
         BNE    LNCLR5       ; JUMP AHEAD IF NOT
         LDA    ADP1+1
         CMP    BRBYT+1
         BNE    LNCLR5       ; JUMP AHEAD IF NOT
         RTS                 ; FINISHED WITH CLEAR IF SO

;        PREPARE TO STAR NEXT LINE

LNCLR5:  LDA    TLBYT        ; ADD NX/8 TO TOP LEFT BYTE ADDRESS
         CLC
         ADC    #NX/8
         STA    TLBYT
         BCC    LNCLR6
         INC    TLBYT+1
LNCLR6:  LDA    TRBYT        ; ADD NX/8 TO TOP RIGHT BYTE ADDRESS
         CLC
         ADC    #NX/8
         STA    TRBYT
         BCC    LNCLR        ; GO PROCESS NEXT LINE
         INC    TRBYT+1
         JMP    LNCLR

;        SADP2L - SHIFT ADP2 LEFT 1 BIT POSITION
;        NO REGISTERS BOTHERED

SADP2L:  ASL    ADP2         ; SHIFT LOW PART
         ROL    ADP2+1       ; SHIFT HIGH PART
         RTS                 ; RETURN

;        DN1SCN - SUBROUTINE TO ADD NX/8 TO ADP1 TO EFFECT A DOWN
;        SHIFT OF ONE SCAN LINE
;        INDEX REGISTERS PRESERVED

DN1SCN:  LDA    ADP1         ; ADD NX/8 TO LOW ADP1
         CLC
         ADC    #NX/8
         STA    ADP1
         BCC    DN1SC1
         INC    ADP1+1       ; INCREMENT HIGH PART IF CARRY FROM LOW
DN1SC1:  RTS                 ; RETURN

;        SUBROUTINE TO ESTABLISH USEFUL DATA ABOUT THE RECTANGLE
;        DEFINED BY THE TEXT MARGINS IN TERMS OF BYTE AND BIT ADDR.
;        TLBYT AND TLBIT DEFINE THE UPPER LEFT CORNER, TRBYT AND TRBIT
;        DEFINE UPPER RIGHT CORNER, BRBYT DEFINES BOTTOM RIGHT CORNER

RECTP:   LDA    X1CORD       ; SAVE CURRENT CURSOR POSITION IN
         STA    X2CORD       ; X2CORD AND Y2CORD
         LDA    X1CORD+1
         STA    X2CORD+1
         LDA    Y1CORD
         STA    Y2CORD
         LDA    Y1CORD+1
         STA    Y2CORD+1
         LDA    LMAR         ; ESTABLISH BYTE AND BIR ADDRESSES OF
         STA    X1CORD       ; TOP LEFT CORNER
         LDA    LMAR+1
         STA    X1CORD+1
         LDA    TMAR
         STA    Y1CORD
         LDA    TMAR+1
         STA    Y1CORD+1
         JSR    PIXADR
         LDA    ADP1
         STA    TLBYT
         LDA    ADP1+1
         STA    TLBYT+1
         LDA    BTPT
         STA    TLBIT
         LDA    RMAR         ; ESTABLISH BYTE AND BIT ADDRESSES OF TOP
         STA    X1CORD       ; RIGHT CORNER
         LDA    RMAR+1
         STA    X1CORD+1
         JSR    PIXADR
         LDA    ADP1
         STA    TRBYT
         LDA    ADP1+1
         STA    TRBYT+1
         LDA    BTPT
         STA    TRBIT
         LDA    BMAR         ; ESTABLISH BYTE ADDRESS OF BOTTOM RIGHT
         STA    Y1CORD       ; CORNER; BIT ADDRESS IS SAME AS BIT
         LDA    BMAR+1       ; ADDRESS OF TOP RIGHT CORNER
         STA    Y1CORD+1
         JSR    PIXADR
         LDA    ADP1
         STA    BRBYT
         LDA    ADP1+1
         STA    BRBYT+1
         RTS                 ; RETURN

;        .PAGE  'CURSOR-BORDER LIMIT TEST ROUTINES'
;        CURSOR-BORDER LIMIT TEST ROUTINES
;        TESTS IF ENOUGH SPACE TO ALLOW CURSOR MOVEMENT IN ANY OF 4
;        RETURNS WITH POSITIVE OR ZERO RESULT IF ENOUGH
;        SPACE AND A NEGATIVE RESULT IF NOT ENOUGH SPACE.
;        SUBROUTINES USE A AND X

DNTST:   LDA    Y1CORD       ; COMPUTE Y1CORD-BMAR-(2*CHHIW-2)
         SEC
         SBC    BMAR         ; SIGN OF RESULT
         TAX                 ; - NOT OK
         LDA    Y1CORD+1     ; Z OK
         SBC    BMAR+1       ; + OK
         PHA
         TXA
         SEC
         SBC    #2*CHHIW-2
         PLA
         SBC    #0
         RTS

UPTST:   LDA    TMAR         ; COMPUTE TMAR-Y1CORD-CHHIW
         SEC
         SBC    Y1CORD       ; SIGN OF RESULT
         TAX                 ; - NOT OK
         LDA    TMAR+1       ; Z OK
         SBC    Y1CORD+1     ; + OK
         PHA
         TXA
         SEC
         SBC    #CHHIW
         PLA
         SBC    #0
         RTS

LFTST:   LDA    X1CORD       ; COMPUTE X1CORD-LMAR-CHWIDW
         SEC
         SBC    LMAR         ; SIGN OF RESULT
         TAX                 ; - NOT OK
         LDA    X1CORD+1     ; Z OK
         SBC    LMAR+1       ; + OK
         PHA
         TXA
         SEC
         SBC    #CHWIDW
         PLA
         SBC    #0
         RTS

RTTST:   LDA    RMAR         ; COMPUTE RMAR-X1CORD-(2*CHWIDW-2)
         SEC
         SBC    X1CORD       ; SIGN OF RESULT
         TAX                 ; - NOT OK
         LDA    RMAR+1       ; Z OK
         SBC    X1CORD+1     ; + OK
         PHA
         TXA
         SEC
         SBC    #2*CHWIDW-2
         PLA
         SBC    #0
         RTS

;        .PAGE  'CURSOR MANIPULATION ROUTINES'
;        CSRINS - INSERT A CURSOR AT THE CURRENT CURSOR POSITION
;                 WHICH IS DEFINED BY X1CORD,Y1CORD
;        CSRDEL - REMOVE THE CURSOR WHICH IS ASSUMED TO BE AT THE
;                 CURRENT CURSOR POSITION
;        CURSOR IS DISPLAYED AS AN UNDERLINE CHHIM+1 SCAN LINES BELOW
;        ACTUAL CHARACTER COORDINATES WHICH SPECIFY THE LOCATION OF THE
;        UPPER LEFT CORNER OF THE CHARACTER
;        INDEX REGISTERS PRESERVED

CSRINS:  LDA    #$F8         ; SET A FOR INSERTING THE CURSOR
         BNE    CSR
CSRDEL:  LDA    #0           ;  SET A FOR DELETING THE CURSOR

CSR:     PHA                 ; SAVE A
         LDA    Y1CORD       ; TEMPORARILY SUBTRACT CHHIM FROM Y1CORD
         SEC
         SBC    #CHHIM
         STA    Y1CORD
         BCS    CSR1
         DEC    Y1CORD-1
CSR1:    JSR    PIXADR       ; COMPUTE ADDRESS OF CURSOR MARK
         PLA                 ; RESTORE SAVED A
         JSR    MERGE5       ; MERGE CURSOR DATA WITH DISPLAY MEMORY
         LDA    Y1CORD       ; RESTORE Y1CORD BY ADDING CHHIM BACK
         CLC
         ADC    #CHHIM
         STA    Y1CORD
         BCC    CSR2
         INC    Y1CORD+1
CSR2:    RTS                 ; RETURN

;        CSRR - MOVE CURSOR RIGHT ROUTINE
;        DO NOTHING IF AGAINST RIGHT MARGIN
;        USES X AND A

CSRR:    JSR    RTTST        ; TEST IF CURSOR CAN GO RIGHT
         BMI    CSRR2        ; GO RETURN IF NOT ENOUGH ROOM
         JSR    CSRDEL       ; DELETE THE PRESENT CURSOR
         LDA    X1CORD       ; ADD CHARACTER WINDOW WIDTH TO X
         CLC                 ; COORDINATE
         ADC    #CHWIDW
         STA    X1CORD
         BCC    CSRR1
         INC    X1CORD+1
CSRR1:   JSR    CSRINS       ; DISPLAY CURSOR AT THE NEW LOCATION
CSRR2:   RTS                 ; RETURN

;        CSRL - MOVE CURSOR LEFT
;        DO NOTHING IF AGAINST LEFT MARGIN
;        USES A AND X

CSRL:    JSR    LFTST        ; TEST IF CURSOR IS TOO FAR LEFT
         BMI    CSRL2        ; JUMP IF IT IS TOO FAR LEFT
         JSR    CSRDEL       ; DELETE THE PRESENT CURSOR
         LDA    X1CORD       ; SUBTRACT CHARACTER WINDOW WIDTH FROM
         SEC                 ; X COORDINATE
         SBC    #CHWIDW
         STA    X1CORD
         BCS    CSRL1
         DEC    X1CORD+1
CSRL1:   JSR    CSRINS       ; DISPLAY CURSOR AT THE NEW LOCATION
CSRL2:   RTS                 ; RETURN

;        CSRU - CURSOR UP F
;        DO NOTHING IF AGAINST TOP MARGIN
;        USES A AND X

CSRU:    JSR    UPTST        ; TEST IF CURSOR IS TOO FAR UP
         BMI    CSRU2        ; JUMP IF IT IS TOO HIGH
         JSR    CSRDEL       ; DELETE THE PRESENT CURSOR
         LDA    Y1CORD       ; ADD CHARACTER WINDOW HEIGHT TO Y
         CLC                 ; COORDINATE
         ADC    #CHHIW
         STA    Y1CORD
         BCC    CSRU1
         INC    Y1CORD+1
CSRU1:   JSR    CSRINS       ; DISPLAY CURSOR AT THE NEW LOCATION
CSRU2:   RTS                 ; RETURN

;        CSRD - CURSOR DOWN
;        DO NOTHING IF AGAINST
;        USES X AND A

CSRD:    JSR    DNTST        ; TEST IF CURSOR IS TOO FAR DOWN
         BMI    CSRD2        ; JUMP IF NOT ENOUGH SPACE
         JSR    CSRDEL       ; DELETE THE CURRENT CURSOR
         LDA    Y1CORD       ; SUBTRACT CHARACTER WINDOW HEIGHT FROM
         SEC                 ; Y COORDINATE
         SBC    #CHHIW
         STA    Y1CORD
         BCS    CSRD1
         DEC    Y1CORD+1
CSRD1:   JSR    CSRINS       ; DISPLAY CURSOR AT THE NEW LOCATION
CSRD2:   RTS                 ; RETURN

;        .PAGE  'CONTROL CHARACTER DISPATCH TABLE'
;        CONTROL CHARACTER DISPATCH TABLE FOR DTEXT
;        FIRST BYTE IS ASCII CONTROL CHARACTER CODE
;        AND THIRD BYTES ARE ADDRESS OF SERVICE ROUTINE

CCTAB:   .BYTE  $0D          ; CR
         .WORD  CARRET-1     ; CARRIAGE RETURN
         .BYTE  $0A          ; LF
         .WORD  LNFED-1      ; LINE FEED
         .BYTE  $08          ; BS
         .WORD  CRL-1        ; BACKSPACE
         .BYTE  $0C          ; FF
         .WORD  FMFED-1      ; FORMFEED (CLEAR SCREEN)
         .BYTE  $0F          ; SI
         .WORD  BASUP-1      ; BASELINE SHIFT UP
         .BYTE  $0E          ; SO
         .WORD  BASDN-1      ; BASELINE SHIFT DOWN
         .BYTE  $11          ; DC1
         .WORD  CRL-1        ; CURSOR LEFT
         .BYTE  $12          ; DC2
         .WORD  CRR-1        ; CURSOR RIGHT
         .BYTE  $13          ; DC3
         .WORD  CRU-1        ; CURSOR UP
         .BYTE  $14          ; DC4
         .WORD  CRD-1        ; CURSOR DOWN
CCTABE:                      ; END OF LIST

;        .PAGE    'CHARACTER FONT TABLE'
;        CHARACTER FONT TABLE 5 WIDE BY 7 HIGH PLUS 2 DESCENDING
;        ENTRIES IN ORDER STARTING AT ASCII BLANK
;        96 ENTRIES
;        EACH ENTRY CONTAINS 8 BYTES
;        SIGN BIT OF FIRST BYTE IS A DESCENDER FLAG, CHARACTER DESCENDS
;        2 ROWS IF IT IS A ONE
;        NEXT 7 BYTES ARE CHARACTER MATRIX, TOP ROW FIRST, LEFTMOST DOT
;        IS LEFTMOST IN BYTE

CHTB:    .BYTE  $00,$00,$00,$00     ; BLANK
         .BYTE  $00,$00,$00,$00
         .BYTE  $00,$20,$20,$20     ; !
         .BYTE  $20,$20,$00,$20
         .BYTE  $00,$50,$50,$50     ; "
         .BYTE  $00,$00,$00,$00
         .BYTE  $00,$50,$50,$F8     ; #
         .BYTE  $50,$F8,$50,$50
         .BYTE  $00,$20,$78,$A0     ; $
         .BYTE  $70,$28,$F0,$20
         .BYTE  $00,$C8,$C8,$10     ; %
         .BYTE  $20,$40,$98,$98
         .BYTE  $00,$40,$A0,$A0     ; &
         .BYTE  $40,$A8,$90,$68
         .BYTE  $00,$30,$30,$30     ; '
         .BYTE  $00,$00,$00,$00
         .BYTE  $00,$20,$40,$40     ; (
         .BYTE  $40,$40,$40,$20
         .BYTE  $00,$20,$10,$10     ; )
         .BYTE  $10,$10,$10,$20
         .BYTE  $00,$20,$A8,$70     ; *
         .BYTE  $20,$70,$A8,$20
         .BYTE  $00,$00,$20,$20     ; +
         .BYTE  $F8,$20,$20,$00
         .BYTE  $80,$00,$00,$00     ; ,
         .BYTE  $30,$30,$10,$20
         .BYTE  $00,$00,$00,$00     ; -
         .BYTE  $F8,$00,$00,$00
         .BYTE  $00,$00,$00,$00     ; .
         .BYTE  $00,$00,$30,$30
         .BYTE  $00,$08,$08,$10     ; /
         .BYTE  $20,$40,$80,$80
         .BYTE  $00,$60,$90,$90     ; 0
         .BYTE  $90,$90,$90,$60
         .BYTE  $00,$20,$60,$20     ; 1
         .BYTE  $20,$20,$20,$70
         .BYTE  $00,$70,$88,$10     ; 2
         .BYTE  $20,$40,$80,$F8
         .BYTE  $00,$70,$88,$08     ; 3
         .BYTE  $30,$08,$88,$70
         .BYTE  $00,$10,$30,$50     ; 4
         .BYTE  $90,$F8,$10,$10
         .BYTE  $00,$F8,$80,$F0     ; 5
         .BYTE  $08,$08,$08,$F0
         .BYTE  $00,$70,$80,$80     ; 6
         .BYTE  $F0,$88,$88,$70
         .BYTE  $00,$F8,$08,$10     ; 7
         .BYTE  $20,$40,$80,$80
         .BYTE  $00,$70,$88,$88     ; 8
         .BYTE  $70,$88,$88,$70
         .BYTE  $00,$70,$88,$88     ; 9
         .BYTE  $78,$08,$08,$70
         .BYTE  $00,$30,$30,$00     ; :
         .BYTE  $00,$00,$30,$30
         .BYTE  $00,$30,$30,$00     ; ;
         .BYTE  $30,$30,$10,$20
         .BYTE  $00,$10,$20,$40     ; LESS THAN
         .BYTE  $80,$40,$20,$10
         .BYTE  $00,$00,$00,$F8     ; =
         .BYTE  $00,$F8,$00,$00
         .BYTE  $00,$40,$20,$10     ; GREATER THAN
         .BYTE  $08,$10,$20,$40
         .BYTE  $00,$70,$88,$08     ; ?
         .BYTE  $10,$20,$00,$20
         .BYTE  $00,$70,$88,$08     ; @
         .BYTE  $68,$A8,$A8,$D0
         .BYTE  $00,$20,$50,$88     ; A
         .BYTE  $88,$F8,$88,$88
         .BYTE  $00,$F0,$48,$48     ; B
         .BYTE  $70,$48,$48,$F0
         .BYTE  $00,$70,$88,$80     ; C
         .BYTE  $80,$80,$88,$70
         .BYTE  $00,$F0,$48,$48     ; D
         .BYTE  $48,$48,$48,$F0
         .BYTE  $00,$F8,$80,$80     ; E
         .BYTE  $F0,$80,$80,$F8
         .BYTE  $00,$F8,$80,$80     ; F
         .BYTE  $F0,$80,$80,$80
         .BYTE  $00,$70,$88,$80     ; G
         .BYTE  $B8,$88,$88,$70
         .BYTE  $00,$88,$88,$88     ; H
         .BYTE  $F8,$88,$88,$88
         .BYTE  $00,$70,$20,$20     ; I
         .BYTE  $20,$20,$20,$70
         .BYTE  $00,$38,$10,$10     ; J
         .BYTE  $10,$10,$90,$60
         .BYTE  $00,$88,$90,$A0     ; K
         .BYTE  $C0,$A0,$90,$88
         .BYTE  $00,$80,$80,$80     ; L
         .BYTE  $80,$80,$80,$F8
         .BYTE  $00,$88,$D8,$A8     ; M
         .BYTE  $A8,$88,$88,$88
         .BYTE  $00,$88,$88,$C8     ; N
         .BYTE  $A8,$98,$88,$88
         .BYTE  $00,$70,$88,$88     ; O
         .BYTE  $88,$88,$88,$70
         .BYTE  $00,$F0,$88,$88     ; P
         .BYTE  $F0,$80,$80,$80
         .BYTE  $00,$70,$88,$88     ; Q
         .BYTE  $88,$A8,$90,$68
         .BYTE  $00,$F0,$88,$88     ; R
         .BYTE  $F0,$A0,$90,$88
         .BYTE  $00,$78,$80,$80     ; S
         .BYTE  $70,$08,$08,$F0
         .BYTE  $00,$F8,$20,$20     ; T
         .BYTE  $20,$20,$20,$20
         .BYTE  $00,$88,$88,$88     ; U
         .BYTE  $88,$88,$88,$70
         .BYTE  $00,$88,$88,$88     ; V
         .BYTE  $50,$50,$20,$20
         .BYTE  $00,$88,$88,$88     ; W
         .BYTE  $A8,$A8,$D8,$88
         .BYTE  $00,$88,$88,$50     ; X
         .BYTE  $20,$50,$88,$88
         .BYTE  $00,$88,$88,$50     ; Y
         .BYTE  $20,$20,$20,$20
         .BYTE  $00,$F8,$08,$10     ; Z
         .BYTE  $20,$40,$80,$F8
         .BYTE  $00,$70,$40,$40     ; LEFT BRACKET
         .BYTE  $40,$40,$40,$70
         .BYTE  $00,$80,$80,$40     ; BACKSLASH
         .BYTE  $20,$10,$08,$08
         .BYTE  $00,$70,$10,$10     ; RIGHT BRACKET
         .BYTE  $10,$10,$10,$70
         .BYTE  $00,$20,$50,$88     ; CARROT
         .BYTE  $00,$00,$00,$00
         .BYTE  $00,$00,$00,$00     ; UNDERLINE
         .BYTE  $00,$00,$00,$F8

         .BYTE  $00,$C0,$60,$30     ; GRAVE ACCENT
         .BYTE  $00,$00,$00,$00
         .BYTE  $00,$00,$60,$10     ; A (LC)
         .BYTE  $70,$90,$90,$68
         .BYTE  $00,$80,$80,$F0     ; B (LC)
         .BYTE  $88,$88,$88,$F0
         .BYTE  $00,$00,$00,$78     ; C (LC)
         .BYTE  $80,$80,$80,$78
         .BYTE  $00,$08,$08,$78     ; D (LC)
         .BYTE  $88,$88,$88,$78
         .BYTE  $00,$00,$00,$70     ; E (LC)
         .BYTE  $88,$F0,$80,$78
         .BYTE  $00,$30,$40,$40     ; F (LC)
         .BYTE  $E0,$40,$40,$40
         .BYTE  $80,$70,$88,$88     ; G (LC)
         .BYTE  $98,$68,$08,$70
         .BYTE  $00,$80,$80,$B0     ; H (LC)
         .BYTE  $C8,$88,$88,$88
         .BYTE  $00,$20,$00,$60     ; I (LC)
         .BYTE  $20,$20,$20,$70
         .BYTE  $80,$70,$10,$10     ; J (LC)
         .BYTE  $10,$10,$90,$60
         .BYTE  $00,$80,$80,$90     ; K (LC)
         .BYTE  $A0,$C0,$A0,$90
         .BYTE  $00,$60,$20,$20     ; L (LC)
         .BYTE  $20,$20,$20,$20
         .BYTE  $00,$00,$00,$D0     ; M (LC)
         .BYTE  $A8,$A8,$A8,$A8
         .BYTE  $00,$00,$00,$B0     ; N (LC)
         .BYTE  $C8,$88,$88,$88
         .BYTE  $00,$00,$00,$70     ; O (LC)
         .BYTE  $88,$88,$88,$70
         .BYTE  $80,$F0,$88,$88     ; P (LC)
         .BYTE  $88,$F0,$80,$80
         .BYTE  $80,$78,$88,$88     ; Q (LC)
         .BYTE  $88,$78,$08,$08
         .BYTE  $00,$00,$00,$B0     ; R (LC)
         .BYTE  $C8,$80,$80,$80
         .BYTE  $00,$00,$00,$78     ; S (LC)
         .BYTE  $80,$70,$08,$F0
         .BYTE  $00,$40,$40,$E0     ; T (LC)
         .BYTE  $40,$40,$50,$20
         .BYTE  $00,$00,$00,$90     ; U (LC)
         .BYTE  $90,$90,$90,$68
         .BYTE  $00,$00,$00,$88     ; V (LC)
         .BYTE  $88,$50,$50,$20
         .BYTE  $00,$00,$00,$A8     ; W (LC)
         .BYTE  $A8,$A8,$A8,$50
         .BYTE  $00,$00,$00,$88     ; X (LC)
         .BYTE  $50,$20,$50,$88
         .BYTE  $80,$88,$88,$88     ; Y (LC)
         .BYTE  $50,$20,$40,$80
         .BYTE  $00,$00,$00,$F8     ; Z (LC)
         .BYTE  $10,$20,$40,$F8
         .BYTE  $00,$10,$20,$20     ; LEFT BRACE
         .BYTE  $60,$20,$20,$10
         .BYTE  $00,$20,$20,$20     ; VERTICAL BAR
         .BYTE  $20,$20,$20,$20
         .BYTE  $00,$40,$20,$20     ; RIGHT BRACE
         .BYTE  $30,$20,$20,$40
         .BYTE  $00,$10,$A8,$40     ; TILDA
         .BYTE  $00,$00,$00,$00
         .BYTE  $00,$A8,$50,$A8     ; RUBOUT
         .BYTE  $50,$A8,$50,$A8

         .END
